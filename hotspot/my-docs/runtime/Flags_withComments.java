[Global flags]
     bool CheckCompressedOops                       = true            {notproduct}Generate checks in encoding/decoding code in debug VM
    uintx HeapBaseMinAddress                        = 2147483648      {pd product}OS specific low limit for heap base address
     bool PrintCompressedOopsMode                   = false           {diagnostic}Print compressed oops base address and encoding mode
     bool AssumeMP                                  = false           {product}Instruct the VM to assume multiple processors are available
     bool UseMembar                                 = false           {pd product}(Unstable) Issues membars on thread state transitions
     bool UsePPCLWSYNC                              = true            {product}Use lwsync instruction if true, else use slower sync
     bool CleanChunkPoolAsync                       = true            {develop}Clean the chunk pool asynchronously
     bool UnlockDiagnosticVMOptions                 = true            {diagnostic}Enable normal processing of flags relating to field diagnostics
     bool JavaMonitorsInStackTrace                  = true            {product}Print information about Java monitor locks when the stacks aredumped
     bool UseLargePages                             = false           {pd product}Use large page memory
     bool UseLargePagesIndividualAllocation        := false           {pd product}Allocate large pages individually for better affinity
     bool LargePagesIndividualAllocationInjectError  = false           {develop}Fail large pages individual allocation
     bool UseLargePagesInMetaspace                  = false           {product}Use large page memory in metaspace. Only used if UseLargePages is enabled.
     bool TracePageSizes                            = false           {develop}Trace page size selection and usage
     bool UseNUMA                                   = false           {product}Use NUMA if available
     bool UseNUMAInterleaving                       = false           {product}Interleave memory across NUMA nodes if available
    uintx NUMAInterleaveGranularity                 = 2097152         {product}Granularity to use for NUMA interleaving on Windows OS
     bool ForceNUMA                                 = false           {product}Force NUMA optimizations on single-node/UMA systems
    uintx NUMAChunkResizeWeight                     = 20              {product}Percentage (0-100) used to weigh the current sample when computing exponentially decaying average for AdaptiveNUMAChunkSizing
    uintx NUMASpaceResizeRate                       = 1073741824      {product}Do not reallocate more than this amount per collection
     bool UseAdaptiveNUMAChunkSizing                = true            {product}Enable adaptive chunk sizing for NUMA
     bool NUMAStats                                 = false           {product}Print NUMA stats in detailed heap information
    uintx NUMAPageScanRate                          = 256             {product}Maximum number of pages to include in the page scan procedure
     bool NeedsDeoptSuspend                         = false           {pd product}True for register window machines (sparc/ia64)
     intx UseSSE                                    = 99              {product}Highest supported SSE instructions set on x86/x64
     bool UseAES                                    = false           {product}Control whether AES instructions can be used on x86/x64
    uintx LargePageSizeInBytes                      = 0               {product}Large page size (0 to let VM choose the page size)
    uintx LargePageHeapSizeThreshold                = 134217728       {product}Use large pages if maximum heap is at least this big
     bool ForceTimeHighResolution                   = false           {product}Using high time resolution (for Win32 only)
     bool TraceItables                              = false           {develop}Trace initialization and use of itables
     bool TracePcPatching                           = false           {develop}Trace usage of frame::patch_pc
     bool TraceJumps                                = false           {develop}Trace assembly jumps in thread ring buffer
     bool TraceRelocator                            = false           {develop}Trace the bytecode relocator
     bool TraceLongCompiles                         = false           {develop}Print out every time compilation is longer than a given threshold
     bool SafepointALot                             = false           {develop}Generate a lot of safepoints. This works with GuaranteedSafepointInterval
     bool BackgroundCompilation                     = true            {pd product}A thread requesting compilation is not blocked during compilation
     bool PrintVMQWaitTime                          = false           {product}Print out the waiting time in VM operation queue
     bool NoYieldsInMicrolock                       = true            {develop}Disable yields in microlock
     bool TraceOopMapGeneration                     = false           {develop}Show OopMapGeneration
     bool MethodFlushing                            = true            {product}Reclamation of zombie and not-entrant methods
     bool VerifyStack                               = false           {develop}Verify stack of each thread when it is entering a runtime call
     bool ForceUnreachable                          = false           {diagnostic}Make all non code cache addresses to be unreachable by forcing use of 64bit literal fixups
     bool StressDerivedPointers                     = false           {notproduct}Force scavenge when a derived pointer is detected on stack after rtm call
     bool TraceDerivedPointers                      = false           {develop}Trace traversal of derived pointers on stack
     bool TraceCodeBlobStacks                       = false           {notproduct}Trace stack-walk of codeblobs
     bool PrintJNIResolving                         = false           {product}Used to implement -v:jni
     bool PrintRewrites                             = false           {notproduct}Print methods that are being rewritten
     bool UseInlineCaches                           = true            {product}Use Inline Caches for virtual calls 
     bool InlineArrayCopy                           = true            {develop}Inline arraycopy native that is known to be part of base library DLL
     bool InlineObjectHash                          = true            {develop}Inline Object::hashCode() native that is known to be part of base library DLL
     bool InlineNatives                             = true            {develop}Inline natives that are known to be part of base library DLL
     bool InlineMathNatives                         = true            {develop}Inline SinD, CosD, etc.
     bool InlineClassNatives                        = true            {develop}Inline Class.isInstance, etc
     bool InlineThreadNatives                       = true            {develop}Inline Thread.currentThread, etc
     bool InlineUnsafeOps                           = true            {develop}Inline memory ops (native methods) from sun.misc.Unsafe
     bool CriticalJNINatives                        = true            {product}Check for critical JNI entry points
     bool StressCriticalJNINatives                  = false           {notproduct}Exercise register saving code in critical natives
     bool UseSSE42Intrinsics                        = false           {product}SSE4.2 versions of intrinsics
     bool UseAESIntrinsics                          = false           {product}Use intrinsics for AES versions of crypto
     bool UseCRC32Intrinsics                        = false           {product}use intrinsics for java.util.zip.CRC32
     bool TraceCallFixup                            = false           {develop}Trace all call fixups
     bool DeoptimizeALot                            = false           {develop}Deoptimize at every exit from the runtime system
ccstrlist DeoptimizeOnlyAt                          =                 {notproduct}A comma separated list of bcis to deoptimize at
     bool DeoptimizeRandom                          = false           {product}Deoptimize random frames on random exit from the runtime system
     bool ZombieALot                                = false           {notproduct}Create zombies (non-entrant) at exit from the runtime system
     bool UnlinkSymbolsALot                         = false           {product}Unlink unreferenced symbols from the symbol table at safepoints
     bool WalkStackALot                             = false           {notproduct}Trace stack (no print) at every exit from the runtime system
     bool Debugging                                 = false           {product}Set when executing debug methods in debug.cpp (to prevent triggering assertions)
     bool StrictSafepointChecks                     = true            {notproduct}Enable strict checks that safepoints cannot happen for threads that use No_Safepoint_Verifier
     bool VerifyLastFrame                           = false           {notproduct}Verify oops on last frame on entry to VM
     bool TraceHandleAllocation                     = false           {develop}Print out warnings when suspiciously many handles are allocated
     bool UseCompilerSafepoints                     = true            {product}Stop at safepoints in compiled code
     bool FailOverToOldVerifier                     = true            {product}Fail over to old verifier when split verifier fails
     bool ShowSafepointMsgs                         = false           {develop}Show message about safepoint synchronization
     bool SafepointTimeout                          = false           {product}Time out and warn or fail after SafepointTimeoutDelay milliseconds if failed to reach safepoint
     bool DieOnSafepointTimeout                     = false           {develop}Die upon failure to reach safepoint (see SafepointTimeout)
     intx SuspendRetryCount                         = 50              {product}Maximum retry count for an external suspend request
     intx SuspendRetryDelay                         = 5               {product}Milliseconds to delay per retry (* current_retry_count)
     bool AssertOnSuspendWaitFailure                = false           {product}Assert/Guarantee on external suspend wait failure
     bool TraceSuspendWaitFailures                  = false           {product}Trace external suspend wait failures
     bool MaxFDLimit                                = true            {product}Bump the number of file descriptors to maximum in Solaris
     bool LogEvents                                 = true            {diagnostic}Enable the various ring buffer event logs
    uintx LogEventsBufferEntries                    = 10              {diagnostic}Number of ring buffer event logs
     bool BytecodeVerificationRemote                = true            {product}Enable the Java bytecode verifier for remote classes
     bool BytecodeVerificationLocal                 = false           {product}Enable the Java bytecode verifier for local classes
     bool ForceFloatExceptions                      = true            {develop}Force exceptions on FP stack under/overflow
     bool VerifyStackAtCalls                        = false           {develop}Verify that the stack pointer is unchanged after calls
     bool TraceJavaAssertions                       = false           {develop}Trace java language assertions
     bool CheckAssertionStatusDirectives            = false           {notproduct}Temporary - see javaClasses.cpp
     bool PrintMallocFree                           = false           {notproduct}Trace calls to C heap malloc/free allocation
     bool PrintOopAddress                           = false           {product}Always print the location of the oop
     bool VerifyCodeCacheOften                      = false           {notproduct}Verify compiled-code cache often
     bool ZapDeadCompiledLocals                     = false           {develop}Zap dead locals in compiler frames
     bool ZapDeadLocalsOld                          = false           {notproduct}Zap dead locals (old version, zaps all frames when entering the VM
     bool CheckOopishValues                         = false           {notproduct}Warn if value contains oop (requires ZapDeadLocals)
     bool UseMallocOnly                             = false           {develop}Use only malloc/free for allocation (no resource area/arena)
     bool PrintMalloc                               = false           {develop}Print all malloc/free calls
     bool PrintMallocStatistics                     = false           {develop}Print malloc/free statistics
     bool ZapResourceArea                           = true            {develop}Zap freed resource/arena space with 0xABABABAB
     bool ZapVMHandleArea                           = true            {notproduct}Zap freed VM handle space with 0xBCBCBCBC
     bool ZapJNIHandleArea                          = true            {develop}Zap freed JNI handle space with 0xFEFEFEFE
     bool ZapStackSegments                          = true            {notproduct}Zap allocated/freed stack segments with 0xFADFADED
     bool ZapUnusedHeapArea                         = true            {develop}Zap unused heap space with 0xBAADBABE
     bool TraceZapUnusedHeapArea                    = false           {develop}Trace zapping of unused heap space
     bool CheckZapUnusedHeapArea                    = false           {develop}Check zapping of unused heap space
     bool ZapFillerObjects                          = true            {develop}Zap filler objects with 0xDEAFBABE
     bool PrintVMMessages                           = true            {develop}Print VM messages on console
     bool PrintGCApplicationConcurrentTime          = false           {product}Print the time the application has been running
     bool PrintGCApplicationStoppedTime             = false           {product}Print the time the application has been stopped
     bool VerboseVerification                       = false           {diagnostic}Display detailed verification details
    uintx ErrorHandlerTest                          = 0               {notproduct}If > 0, provokes an error after VM initialization; the value determines which error to provoke. See test_error_handler() in debug.cpp.
     bool Verbose                                   = false           {develop}Print additional debugging information from other modes
     bool PrintMiscellaneous                        = false           {develop}Print uncategorized debugging information (requires +Verbose)
     bool WizardMode                                = false           {develop}Print much more debugging information
     bool ShowMessageBoxOnError                     = false           {product}Keep process alive on VM fatal error
     bool CreateMinidumpOnCrash                     = false           {product}Create minidump on VM fatal error
     bool UseOSErrorReporting                       = false           {pd product}Let VM fatal error propagate to the OS (ie. WER on Windows)
     bool SuppressFatalErrorMessage                 = false           {product}Report NO fatal error message (avoid deadlock)
ccstrlist OnError                                   =                 {product}Run user-defined commands on fatal error; see VMError.cpp for examples
ccstrlist OnOutOfMemoryError                        =                 {product}Run user-defined commands on first java.lang.OutOfMemoryError
     bool HeapDumpBeforeFullGC                      = false           {manageable}Dump heap to file before any major stop-the-world GC
     bool HeapDumpAfterFullGC                       = false           {manageable}Dump heap to file after any major stop-the-world GC
     bool HeapDumpOnOutOfMemoryError                = false           {manageable}Dump heap to file when java.lang.OutOfMemoryError is thrown
    ccstr HeapDumpPath                              =                 {manageable}When HeapDumpOnOutOfMemoryError is on, the path (filename or directory) of the dump file (defaults to java_pid<pid>.hprof in the working directory)
    uintx SegmentedHeapDumpThreshold                = 2147483648      {develop}Generate a segmented heap dump (JAVA PROFILE 1.0.2 format) when the heap usage is larger than this
    uintx HeapDumpSegmentSize                       = 1073741824      {develop}Approximate segment size when generating a segmented heap dump
     bool BreakAtWarning                            = false           {develop}Execute breakpoint upon encountering VM warning
     bool TraceVMOperation                          = false           {develop}Trace VM operations
     bool UseFakeTimers                             = false           {develop}Tell whether the VM should use system time or a fake timer
    ccstr NativeMemoryTracking                      = off             {product}Native memory tracking options
     bool PrintNMTStatistics                        = false           {diagnostic}Print native memory tracking summary data if it is on
     bool AutoShutdownNMT                           = true            {diagnostic}Automatically shutdown native memory tracking under stress situations. When set to false, native memory tracking tries to stay alive at the expense of JVM performance
     bool LogCompilation                            = false           {diagnostic}Log compilation activity in detail to LogFile
     bool PrintCompilation                          = false           {product}Print compilations
     bool TraceNMethodInstalls                      = false           {diagnostic}Trace nmethod installation
     intx ScavengeRootsInCode                       = 2               {diagnostic}0: do not allow scavengable oops in the code cache; 1: allow scavenging from the code cache; 2: emit as many constants as the compiler can see
     bool AlwaysRestoreFPU                          = false           {product}Restore the FPU control word after every JNI call (expensive)
     bool PrintCompilation2                         = false           {diagnostic}Print additional statistics per compilation
     bool PrintAdapterHandlers                      = false           {diagnostic}Print code generated for i2c/c2i adapters
     bool VerifyAdapterCalls                        = true            {diagnostic}Verify that i2c/c2i adapters are called properly
     bool VerifyAdapterSharing                      = false           {develop}Verify that the code for shared adapters is the equivalent
     bool PrintAssembly                             = false           {diagnostic}Print assembly code (using external disassembler.so)
    ccstr PrintAssemblyOptions                      =                 {diagnostic}Print options string passed to disassembler.so
     bool PrintNMethods                             = false           {diagnostic}Print assembly code for nmethods when generated
     bool PrintNativeNMethods                       = false           {diagnostic}Print assembly code for native nmethods when generated
     bool PrintDebugInfo                            = false           {develop}Print debug information for all nmethods when generated
     bool PrintRelocations                          = false           {develop}Print relocation information for all nmethods when generated
     bool PrintDependencies                         = false           {develop}Print dependency information for all nmethods when generated
     bool PrintExceptionHandlers                    = false           {develop}Print exception handler tables for all nmethods when generated
     bool StressCompiledExceptionHandlers           = false           {develop}Exercise compiled exception handlers
     bool InterceptOSException                      = false           {develop}Start debugger when an implicit OS (e.g. NULL) exception happens
     bool PrintCodeCache                            = false           {product}Print the code cache memory usage when exiting
     bool PrintCodeCache2                           = false           {develop}Print detailed usage information on the code cache when exiting
     bool PrintCodeCacheOnCompilation               = false           {product}Print the code cache memory usage each time a method is compiled
     bool PrintStubCode                             = false           {diagnostic}Print generated stub code
     bool StackTraceInThrowable                     = true            {product}Collect backtrace in throwable when exception happens
     bool OmitStackTraceInFastThrow                 = true            {product}Omit backtraces for some 'hot' exceptions in optimized code
     bool ProfilerPrintByteCodeStatistics           = false           {product}Print bytecode statistics when dumping profiler output
     bool ProfilerRecordPC                          = false           {product}Collect ticks for each 16 byte interval of compiled code
     bool ProfileVM                                 = false           {product}Profile ticks that fall within VM (either in the VM Thread or VM code called through stubs)
     bool ProfileIntervals                          = false           {product}Print profiles for each interval (see ProfileIntervalsTicks)
     bool ProfilerCheckIntervals                    = false           {notproduct}Collect and print information on spacing of profiler ticks
     bool PrintJVMWarnings                          = false           {develop}Print warnings for unimplemented JVM functions
     bool PrintWarnings                             = true            {product}Print JVM warnings to output stream
    uintx WarnOnStalledSpinLock                     = 0               {notproduct}Print warnings for stalled SpinLocks
     bool RegisterFinalizersAtInit                  = true            {product}Register finalizable objects at end of Object.<init> or after allocation
     bool RegisterReferences                        = true            {develop}Tell whether the VM should register soft/weak/final/phantom references
     bool IgnoreRewrites                            = false           {develop}Suppress rewrites of bytecodes in the oopmap generator. This is unsafe!
     bool PrintCodeCacheExtension                   = false           {develop}Print extension of code cache
     bool UsePrivilegedStack                        = true            {develop}Enable the security JVM functions
     bool ProtectionDomainVerification              = true            {develop}Verify protection domain before resolution in system dictionary
     bool ClassUnloading                            = true            {product}Do unloading of classes
     bool DisableStartThread                        = false           {develop}Disable starting of additional Java threads (for debugging only)
     bool MemProfiling                              = false           {develop}Write memory usage profiling to log file
     bool PrintSystemDictionaryAtExit               = false           {notproduct}Print the system dictionary at exit
     bool UnsyncloadClass                           = false           {diagnostic}Unstable: VM calls loadClass unsynchronized. Custom class loader must call VM synchronized for findClass and defineClass.
     bool AlwaysLockClassLoader                     = false           {product}Require the VM to acquire the class loader lock before calling loadClass() even for class loaders registering as parallel capable
     bool AllowParallelDefineClass                  = false           {product}Allow parallel defineClass requests for class loaders registering as parallel capable
     bool MustCallLoadClassInternal                 = false           {product}Call loadClassInternal() rather than loadClass()
     bool DontYieldALot                             = false           {pd product}Throw away obvious excess yield calls (for Solaris only)
     bool ConvertSleepToYield                       = true            {pd product}Convert sleep(0) to thread yield (may be off for Solaris to improve GUI)
     bool ConvertYieldToSleep                       = false           {product}Convert yield to a sleep of MinSleepInterval to simulate Win32 behavior (Solaris only)
     bool UseBoundThreads                           = true            {product}Bind user level threads to kernel threads (for Solaris only)
     bool UseDetachedThreads                        = true            {develop}Use detached threads that are recycled upon termination (for Solaris only)
     bool UseLWPSynchronization                     = true            {product}Use LWP-based instead of libthread-based synchronization (SPARC only)
    ccstr SyncKnobs                                 =                 {product}(Unstable) Various monitor synchronization tunables
     intx EmitSync                                  = 0               {product}(Unsafe, Unstable) Control emission of inline sync fast-path code
     intx MonitorBound                              = 0               {product}Bound Monitor population
     bool MonitorInUseLists                         = false           {product}Track Monitors for Deflation
     intx SyncFlags                                 = 0               {product}(Unsafe, Unstable) Experimental Sync flags
     intx SyncVerbose                               = 0               {product}(Unstable)
     intx ClearFPUAtPark                            = 0               {product}(Unsafe, Unstable)
     intx hashCode                                  = 5               {product}(Unstable) select hashCode generation algorithm
     intx WorkAroundNPTLTimedWaitHang               = 1               {product}(Unstable, Linux-specific) avoid NPTL-FUTEX hang pthread_cond_timedwait
     bool FilterSpuriousWakeups                     = true            {product}Prevent spurious or premature wakeups from object.wait (Solaris only)
     intx NativeMonitorTimeout                      = -1              {product}(Unstable)
     intx NativeMonitorFlags                        = 0               {product}(Unstable)
     intx NativeMonitorSpinLimit                    = 20              {product}(Unstable)
     bool UsePthreads                               = false           {develop}Use pthread-based instead of libthread-based synchronization (SPARC only)
     bool AdjustConcurrency                         = false           {product}Call thr_setconcurrency at thread creation time to avoid LWP starvation on MP systems (for Solaris Only)
     bool ReduceSignalUsage                         = false           {product}Reduce the use of OS signals in Java and/or the VM
     bool ShareVtableStubs                          = true            {pd develop}Share vtable stubs (smaller code but worse branch prediction
     bool LoadLineNumberTables                      = true            {develop}Tell whether the class file parser loads line number tables
     bool LoadLocalVariableTables                   = true            {develop}Tell whether the class file parser loads local variable tables
     bool LoadLocalVariableTypeTables               = true            {develop}Tell whether the class file parser loads local variable typetables
     bool AllowUserSignalHandlers                   = false           {product}Do not complain if the application installs signal handlers (Solaris & Linux only)
     bool UseSignalChaining                         = true            {product}Use signal-chaining to invoke signal handlers installed by the application (Solaris & Linux only)
     bool UseAltSigs                                = false           {product}Use alternate signals instead of SIGUSR1 & SIGUSR2 for VM internal signals (Solaris only)
     bool AllowJNIEnvProxy                          = false           {product}Allow JNIEnv proxies for jdbx
     bool JNIDetachReleasesMonitors                 = true            {product}JNI DetachCurrentThread releases monitors owned by thread
     bool RestoreMXCSROnJNICalls                    = false           {product}Restore MXCSR when returning from JNI calls
     bool CheckJNICalls                             = false           {product}Verify all arguments to JNI calls
     bool UseFastJNIAccessors                       = true            {product}Use optimized versions of Get<Primitive>Field
     bool EagerXrunInit                             = false           {product}Eagerly initialize -Xrun libraries; allows startup profiling, but not all -Xrun libraries may support the state of the VM at this time
     bool PreserveAllAnnotations                    = false           {product}Preserve RuntimeInvisibleAnnotations as well as RuntimeVisibleAnnotations
    uintx PreallocatedOutOfMemoryErrorCount         = 4               {develop}Number of OutOfMemoryErrors preallocated with backtrace
     bool LazyBootClassLoader                       = true            {product}Enable/disable lazy opening of boot class path entries
     bool UseXMMForArrayCopy                        = false           {product}Use SSE2 MOVQ instruction for Arraycopy
     intx FieldsAllocationStyle                     = 1               {product}0 - type based with oops first, 1 - with oops last, 2 - oops in super and sub classes are together
     bool CompactFields                             = true            {product}Allocate nonstatic fields in gaps between previous fields
     bool PrintFieldLayout                          = false           {notproduct}Print field layout for each class
     intx ContendedPaddingWidth                     = 128             {product}How many bytes to pad the fields/classes marked @Contended with
     bool EnableContended                           = true            {product}Enable @Contended annotation support
     bool RestrictContended                         = true            {product}Restrict @Contended to trusted classes
     bool UseBiasedLocking                          = true            {product}Enable biased locking in JVM
     intx BiasedLockingStartupDelay                 = 4000            {product}Number of milliseconds to wait before enabling biased locking
     bool PrintBiasedLockingStatistics              = false           {diagnostic}Print statistics of biased locking in JVM
     intx BiasedLockingBulkRebiasThreshold          = 20              {product}Threshold of number of revocations per type to try to rebias all objects in the heap of that type
     intx BiasedLockingBulkRevokeThreshold          = 40              {product}Threshold of number of revocations per type to permanently revoke biases of all objects in the heap of that type
     intx BiasedLockingDecayTime                    = 25000           {product}Decay time (in milliseconds) to re-enable bulk rebiasing of a type after previous bulk rebias
     bool TraceRuntimeCalls                         = false           {notproduct}Trace run-time calls
     bool TraceJNICalls                             = false           {develop}Trace JNI calls
     bool TraceJVMCalls                             = false           {notproduct}Trace JVM calls
    ccstr TraceJVMTI                                =                 {product}Trace flags for JVMTI functions and events
     bool StressLdcRewrite                          = false           {product}Force ldc -> ldc_w rewrite during RedefineClasses
     intx TraceRedefineClasses                      = 0               {product}Trace level for JVMTI RedefineClasses
     bool StressMethodComparator                    = false           {develop}Run the MethodComparator on all loaded methods
     bool VerifyMergedCPBytecodes                   = true            {product}Verify bytecodes after RedefineClasses constant pool merging
     bool TraceJNIHandleAllocation                  = false           {develop}Trace allocation/deallocation of JNI handle blocks
     bool TraceThreadEvents                         = false           {develop}Trace all thread events
     bool TraceBytecodes                            = false           {develop}Trace bytecode execution
     bool TraceClassInitialization                  = false           {develop}Trace class initialization
     bool TraceExceptions                           = false           {develop}Trace exceptions
     bool TraceICs                                  = false           {develop}Trace inline cache changes
     bool TraceInvocationCounterOverflow            = false           {notproduct}Trace method invocation counter overflow
     bool TraceInlineCacheClearing                  = false           {develop}Trace clearing of inline caches in nmethods
     bool TraceDependencies                         = false           {develop}Trace dependencies
     bool VerifyDependencies                        = true            {develop}Exercise and verify the compilation dependency mechanism
     bool TraceNewOopMapGeneration                  = false           {develop}Trace OopMapGeneration
     bool TraceNewOopMapGenerationDetailed          = false           {develop}Trace OopMapGeneration: print detailed cell states
     bool TimeOopMap                                = false           {develop}Time calls to GenerateOopMap::compute_map() in sum
     bool TimeOopMap2                               = false           {develop}Time calls to GenerateOopMap::compute_map() individually
     bool TraceMonitorMismatch                      = false           {develop}Trace monitor matching failures during OopMapGeneration
     bool TraceOopMapRewrites                       = false           {develop}Trace rewriting of method oops during oop map generation
     bool TraceSafepoint                            = false           {develop}Trace safepoint operations
     bool TraceICBuffer                             = false           {develop}Trace usage of IC buffer
     bool TraceCompiledIC                           = false           {develop}Trace changes of compiled IC
     bool TraceZapDeadLocals                        = false           {notproduct}Trace zapping dead locals
     bool TraceStartupTime                          = false           {develop}Trace setup time
     bool TraceProtectionDomainVerification         = false           {develop}Trace protection domain verification
     bool TraceClearedExceptions                    = false           {develop}Print when an exception is forcibly cleared
     bool TraceClassResolution                      = false           {product}Trace all constant pool resolutions (for debugging)
     bool TraceBiasedLocking                        = false           {product}Trace biased locking in JVM
     bool TraceMonitorInflation                     = false           {product}Trace monitor inflation in JVM
     bool UseSerialGC                               = false           {product}Use the Serial garbage collector
     bool UseG1GC                                   = false           {product}Use the Garbage-First garbage collector
     bool UseParallelGC                             = false           {product}Use the Parallel Scavenge garbage collector
     bool UseParallelOldGC                          = false           {product}Use the Parallel Old garbage collector
    uintx HeapMaximumCompactionInterval             = 20              {product}How often should we maximally compact the heap (not allowing any dead space)
    uintx HeapFirstMaximumCompactionCount           = 3               {product}The collection count for the first maximum compaction
     bool UseMaximumCompactionOnSystemGC            = true            {product}Use maximum compaction in the Parallel Old garbage collector for a system GC
    uintx ParallelOldDeadWoodLimiterMean            = 50              {product}The mean used by the parallel compact dead wood limiter (a number between 0-100)
    uintx ParallelOldDeadWoodLimiterStdDev          = 80              {product}The standard deviation used by the parallel compact dead wood limiter (a number between 0-100)
    uintx ParallelGCThreads                         = 0               {product}Number of parallel threads parallel gc will use
     bool UseDynamicNumberOfGCThreads               = false           {product}Dynamically choose the number of parallel threads parallel gc will use
     bool ForceDynamicNumberOfGCThreads             = false           {diagnostic}Force dynamic selection of the number of parallel threads parallel gc will use to aid debugging
    uintx HeapSizePerGCThread                       = 67108864        {product}Size of heap (bytes) per GC thread used in calculating the number of GC threads
     bool TraceDynamicGCThreads                     = false           {product}Trace the dynamic GC thread usage
     bool ParallelOldGCSplitALot                    = false           {develop}Provoke splitting (copying data from a young gen space to multiple destination spaces)
    uintx ParallelOldGCSplitInterval                = 3               {develop}How often to provoke splitting a young gen space
    uintx ConcGCThreads                             = 0               {product}Number of threads concurrent gc will use
    uintx YoungPLABSize                             = 4096            {product}Size of young gen promotion LAB's (in HeapWords)
    uintx OldPLABSize                               = 1024            {product}Size of old gen promotion LAB's (in HeapWords)
    uintx GCTaskTimeStampEntries                    = 200             {product}Number of time stamp entries per gc worker thread
     bool AlwaysTenure                              = false           {product}Always tenure objects in eden (ParallelGC only)
     bool NeverTenure                               = false           {product}Never tenure objects in eden, may tenure on overflow (ParallelGC only)
     bool ScavengeBeforeFullGC                      = true            {product}Scavenge youngest generation before each full GC, used with UseParallelGC
     bool ScavengeWithObjectsInToSpace              = false           {develop}Allow scavenges to occur when to-space contains objects
     bool UseConcMarkSweepGC                        = false           {product}Use Concurrent Mark-Sweep GC in the old generation
     bool ExplicitGCInvokesConcurrent               = false           {product}A System.gc() request invokes a concurrent collection; (effective only when UseConcMarkSweepGC)
     bool ExplicitGCInvokesConcurrentAndUnloadsClasses  = false           {product}A System.gc() request invokes a concurrent collection and also unloads classes during such a concurrent gc cycle (effective only when UseConcMarkSweepGC)
     bool GCLockerInvokesConcurrent                 = false           {product}The exit of a JNI critical section necessitating a scavenge, also kicks off a background concurrent collection
    uintx GCLockerEdenExpansionPercent              = 5               {product}How much the GC can expand the eden by while the GC locker is active (as a percentage)
     intx GCLockerRetryAllocationCount              = 2               {diagnostic}Number of times to retry allocations when blocked by the GC locker
     bool UseCMSAdaptiveFreeLists                   = true            {develop}Use adaptive free lists in the CMS generation
     bool UseAsyncConcMarkSweepGC                   = true            {develop}Use Asynchronous Concurrent Mark-Sweep GC in the old generation
     bool RotateCMSCollectionTypes                  = false           {develop}Rotate the CMS collections among concurrent and STW
     bool UseCMSBestFit                             = true            {product}Use CMS best fit allocation strategy
     bool UseCMSCollectionPassing                   = true            {product}Use passing of collection from background to foreground
     bool UseParNewGC                               = false           {product}Use parallel threads in the new generation
     bool ParallelGCVerbose                         = false           {product}Verbose output for parallel gc
    uintx ParallelGCBufferWastePct                  = 10              {product}Wasted fraction of parallel allocation buffer
     bool ParallelGCRetainPLAB                      = false           {diagnostic}Retain parallel allocation buffers across scavenges; it is disabled because this currently conflicts with parallel card scanning under certain conditions.
    uintx TargetPLABWastePct                        = 10              {product}Target wasted space in last buffer as percent of overall allocation
    uintx PLABWeight                                = 75              {product}Percentage (0-100) used to weigh the current sample when computing exponentially decaying average for ResizePLAB
     bool ResizePLAB                                = true            {product}Dynamically resize (survivor space) promotion LAB's
     bool PrintPLAB                                 = false           {product}Print (survivor space) promotion LAB's sizing decisions
     intx ParGCArrayScanChunk                       = 50              {product}Scan a subset of object array and push remainder, if array is bigger than this
     bool ParGCUseLocalOverflow                     = false           {product}Instead of a global overflow list, use local overflow stacks
     bool ParGCTrimOverflow                         = true            {product}Eagerly trim the local overflow lists (when ParGCUseLocalOverflow)
     bool ParGCWorkQueueOverflowALot                = false           {notproduct}Simulate work queue overflow in ParNew
    uintx ParGCWorkQueueOverflowInterval            = 1000            {notproduct}An `interval' counter that determines how frequently we simulate overflow; a smaller number increases frequency
    uintx ParGCDesiredObjsFromOverflowList          = 20              {product}The desired number of objects to claim from the overflow list
    uintx ParGCStridesPerThread                     = 2               {diagnostic}The number of strides per worker thread that we divide up the card table scanning work into
     intx ParGCCardsPerStrideChunk                  = 256             {diagnostic}The number of cards in each chunk of the parallel chunks used during card table scanning
    uintx CMSParPromoteBlocksToClaim                = 16              {product}Number of blocks to attempt to claim when refilling CMS LAB's for parallel GC
    uintx OldPLABWeight                             = 50              {product}Percentage (0-100) used to weight the current sample when computing exponentially decaying average for resizing CMSParPromoteBlocksToClaim
     bool ResizeOldPLAB                             = true            {product}Dynamically resize (old gen) promotion LAB's
     bool PrintOldPLAB                              = false           {product}Print (old gen) promotion LAB's sizing decisions
    uintx CMSOldPLABMin                             = 16              {product}Minimum size of CMS gen promotion LAB caches per worker per block size
    uintx CMSOldPLABMax                             = 1024            {product}Maximum size of CMS gen promotion LAB caches per worker per block size
    uintx CMSOldPLABNumRefills                      = 4               {product}Nominal number of refills of CMS gen promotion LAB cache per worker per block size
     bool CMSOldPLABResizeQuicker                   = false           {product}React on-the-fly during a scavenge to a sudden change in block demand rate
    uintx CMSOldPLABToleranceFactor                 = 4               {product}The tolerance of the phase-change detector for on-the-fly PLAB resizing during a scavenge
    uintx CMSOldPLABReactivityFactor                = 2               {product}The gain in the feedback loop for on-the-fly PLAB resizing during a scavenge
     bool AlwaysPreTouch                            = false           {product}Force all freshly committed pages to be pre-touched
    uintx CMSYoungGenPerWorker                      = 67108864        {pd product}The maximum size of young gen chosen by default per GC worker thread available
     bool CMSIncrementalMode                        = false           {product}Whether CMS GC should operate in "incremental" mode
    uintx CMSIncrementalDutyCycle                   = 10              {product}Percentage (0-100) of CMS incremental mode duty cycle. If CMSIncrementalPacing is enabled, then this is just the initial value.
     bool CMSIncrementalPacing                      = true            {product}Whether the CMS incremental mode duty cycle should be automatically adjusted
    uintx CMSIncrementalDutyCycleMin                = 0               {product}Minimum percentage (0-100) of the CMS incremental duty cycle used when CMSIncrementalPacing is enabled
    uintx CMSIncrementalSafetyFactor                = 10              {product}Percentage (0-100) used to add conservatism when computing the duty cycle
    uintx CMSIncrementalOffset                      = 0               {product}Percentage (0-100) by which the CMS incremental mode duty cycle is shifted to the right within the period between young GCs
    uintx CMSExpAvgFactor                           = 50              {product}Percentage (0-100) used to weigh the current sample when computing exponential averages for CMS statistics
    uintx CMS_FLSWeight                             = 75              {product}Percentage (0-100) used to weigh the current sample when computing exponentially decaying averages for CMS FLS statistics
    uintx CMS_FLSPadding                            = 1               {product}The multiple of deviation from mean to use for buffering against volatility in free list demand
    uintx FLSCoalescePolicy                         = 2               {product}CMS: aggressiveness level for coalescing, increasing from 0 to 4
     bool FLSAlwaysCoalesceLarge                    = false           {product}CMS: larger free blocks are always available for coalescing
   double FLSLargestBlockCoalesceProximity          = 0.990000        {product}CMS: the smaller the percentage the greater the coalescing force
   double CMSSmallCoalSurplusPercent                = 1.050000        {product}CMS: the factor by which to inflate estimated demand of small block sizes to prevent coalescing with an adjoining block
   double CMSLargeCoalSurplusPercent                = 0.950000        {product}CMS: the factor by which to inflate estimated demand of large block sizes to prevent coalescing with an adjoining block
   double CMSSmallSplitSurplusPercent               = 1.100000        {product}CMS: the factor by which to inflate estimated demand of small block sizes to prevent splitting to supply demand for smaller blocks
   double CMSLargeSplitSurplusPercent               = 1.000000        {product}CMS: the factor by which to inflate estimated demand of large block sizes to prevent splitting to supply demand for smaller blocks
     bool CMSExtrapolateSweep                       = false           {product}CMS: cushion for block demand during sweep
    uintx CMS_SweepWeight                           = 75              {product}Percentage (0-100) used to weight the current sample when computing exponentially decaying average for inter-sweep duration
    uintx CMS_SweepPadding                          = 1               {product}The multiple of deviation from mean to use for buffering against volatility in inter-sweep duration
    uintx CMS_SweepTimerThresholdMillis             = 10              {product}Skip block flux-rate sampling for an epoch unless inter-sweep duration exceeds this threshold in milliseconds
     bool CMSTraceIncrementalMode                   = false           {develop}Trace CMS incremental mode
     bool CMSTraceIncrementalPacing                 = false           {develop}Trace CMS incremental mode pacing computation
     bool CMSTraceThreadState                       = false           {develop}Trace the CMS thread state (enable the trace_state() method)
     bool CMSClassUnloadingEnabled                  = true            {product}Whether class unloading enabled when using CMS GC
    uintx CMSClassUnloadingMaxInterval              = 0               {product}When CMS class unloading is enabled, the maximum CMS cycle count for which classes may not be unloaded
     bool CMSCompactWhenClearAllSoftRefs            = true            {product}Compact when asked to collect CMS gen with clear_all_soft_refs()
     bool UseCMSCompactAtFullCollection             = true            {product}Use Mark-Sweep-Compact algorithm at full collections
    uintx CMSFullGCsBeforeCompaction                = 0               {product}Number of CMS full collection done before compaction if > 0
     intx CMSDictionaryChoice                       = 0               {develop}Use BinaryTreeDictionary as default in the CMS generation
    uintx CMSIndexedFreeListReplenish               = 4               {product}Replenish an indexed free list with this number of chunks
     bool CMSReplenishIntermediate                  = true            {product}Replenish all intermediate free-list caches
     bool CMSSplitIndexedFreeListBlocks             = true            {product}When satisfying batched demand, split blocks from the IndexedFreeList whose size is a multiple of requested size
     bool CMSLoopWarn                               = false           {product}Warn in case of excessive CMS looping
     bool CMSOverflowEarlyRestoration               = false           {develop}Restore preserved marks early
    uintx MarkStackSize                             = 32768           {product}Size of marking stack
    uintx MarkStackSizeMax                          = 4194304         {product}Maximum size of marking stack
     bool CMSMarkStackOverflowALot                  = false           {notproduct}Simulate frequent marking stack / work queue overflow
    uintx CMSMarkStackOverflowInterval              = 1000            {notproduct}An "interval" counter that determines how frequently to simulate overflow; a smaller number increases frequency
    uintx CMSMaxAbortablePrecleanLoops              = 0               {product}(Temporary, subject to experimentation) Maximum number of abortable preclean iterations, if > 0
     intx CMSMaxAbortablePrecleanTime               = 5000            {product}(Temporary, subject to experimentation) Maximum time in abortable preclean (in milliseconds)
    uintx CMSAbortablePrecleanMinWorkPerIteration   = 100             {product}(Temporary, subject to experimentation) Nominal minimum work per abortable preclean iteration
     intx CMSAbortablePrecleanWaitMillis            = 100             {manageable}(Temporary, subject to experimentation) Time that we sleep between iterations when not given enough work per iteration
    uintx CMSRescanMultiple                         = 32              {product}Size (in cards) of CMS parallel rescan task
    uintx CMSConcMarkMultiple                       = 32              {product}Size (in cards) of CMS concurrent MT marking task
     bool CMSAbortSemantics                         = false           {product}Whether abort-on-overflow semantics is implemented
     bool CMSParallelInitialMarkEnabled             = true            {product}Use the parallel initial mark.
     bool CMSParallelRemarkEnabled                  = true            {product}Whether parallel remark enabled (only if ParNewGC)
     bool CMSParallelSurvivorRemarkEnabled          = true            {product}Whether parallel remark of survivor space enabled (effective only if CMSParallelRemarkEnabled)
     bool CMSPLABRecordAlways                       = true            {product}Always record survivor space PLAB boundaries (effective only if CMSParallelSurvivorRemarkEnabled)
     bool CMSEdenChunksRecordAlways                 = true            {product}Always record eden chunks used for the parallel initial mark or remark of eden
     bool CMSPrintEdenSurvivorChunks                = false           {product}Print the eden and the survivor chunks used for the parallel initial mark or remark of the eden/survivor spaces
     bool CMSConcurrentMTEnabled                    = true            {product}Whether multi-threaded concurrent work enabled (effective only if ParNewGC)
     bool CMSPrecleaningEnabled                     = true            {product}Whether concurrent precleaning enabled
    uintx CMSPrecleanIter                           = 3               {product}Maximum number of precleaning iteration passes
    uintx CMSPrecleanNumerator                      = 2               {product}CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence ratio
    uintx CMSPrecleanDenominator                    = 3               {product}CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence ratio
     bool CMSPrecleanRefLists1                      = true            {product}Preclean ref lists during (initial) preclean phase
     bool CMSPrecleanRefLists2                      = false           {product}Preclean ref lists during abortable preclean phase
     bool CMSPrecleanSurvivors1                     = false           {product}Preclean survivors during (initial) preclean phase
     bool CMSPrecleanSurvivors2                     = true            {product}Preclean survivors during abortable preclean phase
    uintx CMSPrecleanThreshold                      = 1000            {product}Do not iterate again if number of dirty cards is less than this
     bool CMSCleanOnEnter                           = true            {product}Clean-on-enter optimization for reducing number of dirty cards
    uintx CMSRemarkVerifyVariant                    = 1               {product}Choose variant (1,2) of verification following remark
    uintx CMSScheduleRemarkEdenSizeThreshold        = 2097152         {product}If Eden size is below this, do not try to schedule remark
    uintx CMSScheduleRemarkEdenPenetration          = 50              {product}The Eden occupancy percentage (0-100) at which to try and schedule remark pause
    uintx CMSScheduleRemarkSamplingRatio            = 5               {product}Start sampling eden top at least before young gen occupancy reaches 1/<ratio> of the size at which we plan to schedule remark
    uintx CMSSamplingGrain                          = 16384           {product}The minimum distance between eden samples for CMS (see above)
     bool CMSScavengeBeforeRemark                   = false           {product}Attempt scavenge before the CMS remark step
     bool CMSTraceSweeper                           = false           {develop}Trace some actions of the CMS sweeper
    uintx CMSWorkQueueDrainThreshold                = 10              {product}Don't drain below this size per parallel worker/thief
     intx CMSWaitDuration                           = 2000            {manageable}Time in milliseconds that CMS thread waits for young GC
    uintx CMSCheckInterval                          = 1000            {develop}Interval in milliseconds that CMS thread checks if it should start a collection cycle
     bool CMSYield                                  = true            {product}Yield between steps of CMS
    uintx CMSBitMapYieldQuantum                     = 10485760        {product}Bitmap operations should process at most this many bits between yields
     bool CMSDumpAtPromotionFailure                 = false           {product}Dump useful information about the state of the CMS old generation upon a promotion failure
     bool CMSPrintChunksInDump                      = false           {product}In a dump enabled by CMSDumpAtPromotionFailure, include more detailed information about the free chunks
     bool CMSPrintObjectsInDump                     = false           {product}In a dump enabled by CMSDumpAtPromotionFailure, include more detailed information about the allocated objects
     bool FLSVerifyAllHeapReferences                = false           {diagnostic}Verify that all references across the FLS boundary are to valid objects
     bool FLSVerifyLists                            = false           {diagnostic}Do lots of (expensive) FreeListSpace verification
     bool FLSVerifyIndexTable                       = false           {diagnostic}Do lots of (expensive) FLS index table verification
     bool FLSVerifyDictionary                       = false           {develop}Do lots of (expensive) FLS dictionary verification
     bool VerifyBlockOffsetArray                    = false           {develop}Do (expensive) block offset array verification
     bool BlockOffsetArrayUseUnallocatedBlock       = false           {diagnostic}Maintain _unallocated_block in BlockOffsetArray (currently applicable only to CMS collector)
     bool TraceCMSState                             = false           {develop}Trace the state of the CMS collection
     intx RefDiscoveryPolicy                        = 0               {product}Select type of reference discovery policy: reference-based(0) or referent-based(1)
     bool ParallelRefProcEnabled                    = false           {product}Enable parallel reference processing whenever possible
     bool ParallelRefProcBalancingEnabled           = true            {product}Enable balancing of reference processing queues
    uintx CMSTriggerRatio                           = 80              {product}Percentage of MinHeapFreeRatio in CMS generation that is allocated before a CMS collection cycle commences
    uintx CMSBootstrapOccupancy                     = 50              {product}Percentage CMS generation occupancy at which to initiate CMS collection for bootstrapping collection stats
     intx CMSInitiatingOccupancyFraction            = -1              {product}Percentage CMS generation occupancy to start a CMS collection cycle. A negative value means that CMSTriggerRatio is used
    uintx InitiatingHeapOccupancyPercent            = 45              {product}Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A value of 0 denotes 'do constant GC cycles'.
     bool UseCMSInitiatingOccupancyOnly             = false           {product}Only use occupancy as a criterion for starting a CMS collection
    uintx CMSIsTooFullPercentage                    = 98              {product}An absolute ceiling above which CMS will always consider the unloading of classes when class unloading is enabled
     bool CMSTestInFreeList                         = false           {develop}Check if the coalesced range is already in the free lists as claimed
     bool CMSVerifyReturnedBytes                    = false           {notproduct}Check that all the garbage collected was returned to the free lists
     bool ScavengeALot                              = false           {notproduct}Force scavenge at every Nth exit from the runtime system (N=ScavengeALotInterval)
     bool FullGCALot                                = false           {develop}Force full gc at every Nth exit from the runtime system (N=FullGCALotInterval)
     bool GCALotAtAllSafepoints                     = false           {notproduct}Enforce ScavengeALot/GCALot at all potential safepoints
     bool PrintPromotionFailure                     = false           {product}Print additional diagnostic information following promotion failure
     bool PromotionFailureALot                      = false           {notproduct}Use promotion failure handling on every youngest generation collection
    uintx PromotionFailureALotCount                 = 1000            {develop}Number of promotion failures occurring at ParGCAllocBuffer refill attempts (ParNew) or promotion attempts (other young collectors)
    uintx PromotionFailureALotInterval              = 5               {develop}Total collections between promotion failures alot
    uintx ObjArrayMarkingStride                     = 512             {develop}Number of object array elements to push onto the marking stack before pushing a continuation entry
     bool MetadataAllocationFailALot                = false           {develop}Fail metadata allocations at intervals controlled by MetadataAllocationFailALotInterval
    uintx MetadataAllocationFailALotInterval        = 1000            {develop}Metadata allocation failure a lot interval
     bool TraceMetadataChunkAllocation              = false           {develop}Trace chunk metadata allocations
     bool TraceMetadataHumongousAllocation          = false           {product}Trace humongous metadata allocations
     bool TraceMetavirtualspaceAllocation           = false           {develop}Trace virtual space metadata allocations
     bool ExecuteInternalVMTests                    = false           {notproduct}Enable execution of internal VM tests
     bool VerboseInternalVMTests                    = false           {notproduct}Turn on logging for internal VM tests.
     bool UseTLAB                                   = true            {pd product}Use thread-local object allocation
     bool ResizeTLAB                                = true            {pd product}Dynamically resize TLAB size for threads
     bool ZeroTLAB                                  = false           {product}Zero out the newly created TLAB
     bool FastTLABRefill                            = true            {product}Use fast TLAB refill code
     bool PrintTLAB                                 = false           {product}Print various TLAB related information
     bool TLABStats                                 = true            {product}Provide more detailed and expensive TLAB statistics (with PrintTLAB)
     bool NeverActAsServerClassMachine              = true            {pd product}Never act like a server-class machine
     bool AlwaysActAsServerClassMachine             = false           {product}Always act like a server-class machine
 uint64_t MaxRAM                                    = 1073741824      {pd product}Real memory size (in bytes) used to set maximum heap size
    uintx ErgoHeapSizeLimit                         = 0               {product}Maximum ergonomically set heap size (in bytes); zero means use MaxRAM / MaxRAMFraction
    uintx MaxRAMFraction                            = 4               {product}Maximum fraction (1/n) of real memory used for maximum heap size
    uintx DefaultMaxRAMFraction                     = 4               {product}Maximum fraction (1/n) of real memory used for maximum heap size; deprecated: to be renamed to MaxRAMFraction
    uintx MinRAMFraction                            = 2               {product}Minimum fraction (1/n) of real memory used for maxmimum heap size on systems with small physical memory size
    uintx InitialRAMFraction                        = 64              {product}Fraction (1/n) of real memory used for initial heap size
    uintx MaxVirtMemFraction                        = 2               {develop}Maximum fraction (1/n) of virtual memory used for ergonomically determining maximum heap size
     bool UseAutoGCSelectPolicy                     = false           {product}Use automatic collection selection policy
    uintx AutoGCSelectPauseMillis                   = 5000            {product}Automatic GC selection pause threshold in milliseconds
     bool UseAdaptiveSizePolicy                     = true            {product}Use adaptive generation sizing policies
     bool UsePSAdaptiveSurvivorSizePolicy           = true            {product}Use adaptive survivor sizing policies
     bool UseAdaptiveGenerationSizePolicyAtMinorCollection  = true            {product}Use adaptive young-old sizing policies at minor collections
     bool UseAdaptiveGenerationSizePolicyAtMajorCollection  = true            {product}Use adaptive young-old sizing policies at major collections
     bool UseAdaptiveSizePolicyWithSystemGC         = false           {product}Include statistics from System.gc() for adaptive size policy
     bool UseAdaptiveGCBoundary                     = false           {product}Allow young-old boundary to move
     bool TraceAdaptiveGCBoundary                   = false           {develop}Trace young-old boundary moves
     intx PSAdaptiveSizePolicyResizeVirtualSpaceAlot  = -1              {develop}Resize the virtual spaces of the young or old generations
    uintx AdaptiveSizeThroughPutPolicy              = 0               {product}Policy for changing generation size for throughput goals
    uintx AdaptiveSizePausePolicy                   = 0               {product}Policy for changing generation size for pause goals
     bool PSAdjustTenuredGenForMinorPause           = false           {develop}Adjust tenured generation to achieve a minor pause goal
     bool PSAdjustYoungGenForMajorPause             = false           {develop}Adjust young generation to achieve a major pause goal
    uintx AdaptiveSizePolicyInitializingSteps       = 20              {product}Number of steps where heuristics is used before data is used
    uintx AdaptiveSizePolicyReadyThreshold          = 5               {develop}Number of collections before the adaptive sizing is started
    uintx AdaptiveSizePolicyOutputInterval          = 0               {product}Collection interval for printing information; zero means never
     bool UseAdaptiveSizePolicyFootprintGoal        = true            {product}Use adaptive minimum footprint as a goal
    uintx AdaptiveSizePolicyWeight                  = 10              {product}Weight given to exponential resizing, between 0 and 100
    uintx AdaptiveTimeWeight                        = 25              {product}Weight given to time in adaptive policy, between 0 and 100
    uintx PausePadding                              = 1               {product}How much buffer to keep for pause time
    uintx PromotedPadding                           = 3               {product}How much buffer to keep for promotion failure
    uintx SurvivorPadding                           = 3               {product}How much buffer to keep for survivor overflow
    uintx ThresholdTolerance                        = 10              {product}Allowed collection cost difference between generations
    uintx AdaptiveSizePolicyCollectionCostMargin    = 50              {product}If collection costs are within margin, reduce both by full delta
    uintx YoungGenerationSizeIncrement              = 20              {product}Adaptive size percentage change in young generation
    uintx YoungGenerationSizeSupplement             = 80              {product}Supplement to YoungedGenerationSizeIncrement used at startup
    uintx YoungGenerationSizeSupplementDecay        = 8               {product}Decay factor to YoungedGenerationSizeSupplement
    uintx TenuredGenerationSizeIncrement            = 20              {product}Adaptive size percentage change in tenured generation
    uintx TenuredGenerationSizeSupplement           = 80              {product}Supplement to TenuredGenerationSizeIncrement used at startup
    uintx TenuredGenerationSizeSupplementDecay      = 2               {product}Decay factor to TenuredGenerationSizeIncrement
    uintx MaxGCPauseMillis                          = 4294967295      {product}Adaptive size policy maximum GC pause time goal in millisecond, or (G1 Only) the maximum GC time per MMU time slice
    uintx GCPauseIntervalMillis                     = 0               {product}Time slice for MMU specification
    uintx MaxGCMinorPauseMillis                     = 4294967295      {product}Adaptive size policy maximum GC minor pause time goal in millisecond
    uintx GCTimeRatio                               = 99              {product}Adaptive size policy application time to GC time ratio
    uintx AdaptiveSizeDecrementScaleFactor          = 4               {product}Adaptive size scale down factor for shrinking
     bool UseAdaptiveSizeDecayMajorGCCost           = true            {product}Adaptive size decays the major cost for long major intervals
    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10              {product}Time scale over which major costs decay
    uintx MinSurvivorRatio                          = 3               {product}Minimum ratio of young generation/survivor space size
    uintx InitialSurvivorRatio                      = 8               {product}Initial ratio of young generation/survivor space size
    uintx BaseFootPrintEstimate                     = 268435456       {product}Estimate of footprint other than Java Heap
     bool UseGCOverheadLimit                        = true            {product}Use policy to limit of proportion of time spent in GC before an OutOfMemory error is thrown
    uintx GCTimeLimit                               = 98              {product}Limit of the proportion of time spent in GC before an OutOfMemoryError is thrown (used with GCHeapFreeLimit)
    uintx GCHeapFreeLimit                           = 2               {product}Minimum percentage of free space after a full GC before an OutOfMemoryError is thrown (used with GCTimeLimit)
    uintx AdaptiveSizePolicyGCTimeLimitThreshold    = 5               {develop}Number of consecutive collections before gc time limit fires
     bool PrintAdaptiveSizePolicy                   = false           {product}Print information about AdaptiveSizePolicy
     intx PrefetchCopyIntervalInBytes               = -1              {product}How far ahead to prefetch destination area (<= 0 means off)
     intx PrefetchScanIntervalInBytes               = -1              {product}How far ahead to prefetch scan area (<= 0 means off)
     intx PrefetchFieldsAhead                       = -1              {product}How many fields ahead to prefetch in oop scan (<= 0 means off)
     bool VerifySilently                            = false           {diagnostic}Do not print the verification progress
     bool VerifyDuringStartup                       = false           {diagnostic}Verify memory system before executing any Java code during VM initialization
     bool VerifyBeforeExit                          = true            {diagnostic}Verify system before exiting
     bool VerifyBeforeGC                            = false           {diagnostic}Verify memory system before GC
     bool VerifyAfterGC                             = false           {diagnostic}Verify memory system after GC
     bool VerifyDuringGC                            = false           {diagnostic}Verify memory system during GC (between phases)
     bool GCParallelVerificationEnabled             = true            {diagnostic}Enable parallel memory system verification
     bool DeferInitialCardMark                      = false           {diagnostic}When +ReduceInitialCardMarks, explicitly defer any that may arise from new_pre_store_barrier
     bool VerifyRememberedSets                      = false           {diagnostic}Verify GC remembered sets
     bool VerifyObjectStartArray                    = true            {diagnostic}Verify GC object start array if verify before/after
     bool DisableExplicitGC                         = false           {product}Ignore calls to System.gc()
     bool CheckMemoryInitialization                 = false           {notproduct}Check memory initialization
     bool CollectGen0First                          = false           {product}Collect youngest generation before each full GC
     bool BindCMSThreadToCPU                        = false           {diagnostic}Bind CMS Thread to CPU if possible
    uintx CPUForCMSThread                           = 0               {diagnostic}When BindCMSThreadToCPU is true, the CPU to bind CMS thread to
     bool BindGCTaskThreadsToCPUs                   = false           {product}Bind GCTaskThreads to CPUs if possible
     bool UseGCTaskAffinity                         = false           {product}Use worker affinity when asking for GCTasks
    uintx ProcessDistributionStride                 = 4               {product}Stride through processors when distributing processes
    uintx CMSCoordinatorYieldSleepCount             = 10              {product}Number of times the coordinator GC thread will sleep while yielding before giving up and resuming GC
    uintx CMSYieldSleepCount                        = 0               {product}Number of times a GC thread (minus the coordinator) will sleep while yielding before giving up and resuming GC
     bool PrintGC                                   = false           {manageable}Print message at garbage collection
     bool PrintGCDetails                            = false           {manageable}Print more details at garbage collection
     bool PrintGCDateStamps                         = false           {manageable}Print date stamps at garbage collection
     bool PrintGCTimeStamps                         = false           {manageable}Print timestamps at garbage collection
     bool PrintGCTaskTimeStamps                     = false           {product}Print timestamps for individual gc worker thread tasks
     intx ConcGCYieldTimeout                        = 0               {develop}If non-zero, assert that GC threads yield within this number of milliseconds
     bool TraceMarkSweep                            = false           {notproduct}Trace mark sweep
     bool PrintReferenceGC                          = false           {product}Print times spent handling reference objects during GC (enabled only when PrintGCDetails)
     bool TraceReferenceGC                          = false           {develop}Trace handling of soft/weak/final/phantom references
     bool TraceFinalizerRegistration                = false           {develop}Trace registration of final references
     bool TraceScavenge                             = false           {notproduct}Trace scavenge
     bool TraceClassLoading                         = false           {product rw}Trace all classes loaded
     bool TraceClassLoadingPreorder                 = false           {product}Trace all classes loaded in order referenced (not loaded)
     bool TraceClassUnloading                       = false           {product rw}Trace unloading of classes
     bool TraceLoaderConstraints                    = false           {product rw}Trace loader constraints
     bool TraceClassLoaderData                      = false           {develop}Trace class loader loader_data lifetime
    uintx InitialBootClassLoaderMetaspaceSize       = 2252800         {product}Initial size of the boot class loader data metaspace
     bool TraceGen0Time                             = false           {product}Trace accumulated time for Gen 0 collection
     bool TraceGen1Time                             = false           {product}Trace accumulated time for Gen 1 collection
     bool PrintTenuringDistribution                 = false           {product}Print tenuring age information
     bool PrintHeapAtGC                             = false           {product rw}Print heap layout before and after each GC
     bool PrintHeapAtGCExtended                     = false           {product rw}Print extended information about the layout of the heap when -XX:+PrintHeapAtGC is set
     bool PrintHeapAtSIGBREAK                       = true            {product}Print heap layout in response to SIGBREAK
     bool PrintClassHistogramBeforeFullGC           = false           {manageable}Print a class histogram before any major stop-world GC
     bool PrintClassHistogramAfterFullGC            = false           {manageable}Print a class histogram after any major stop-world GC
     bool PrintClassHistogram                       = false           {manageable}Print a histogram of class instances
     bool TraceWorkGang                             = false           {develop}Trace activities of work gangs
     bool TraceParallelOldGCTasks                   = false           {product}Trace multithreaded GC activity
     bool TraceBlockOffsetTable                     = false           {develop}Print BlockOffsetTable maps
     bool TraceCardTableModRefBS                    = false           {develop}Print CardTableModRefBS maps
     bool TraceGCTaskManager                        = false           {develop}Trace actions of the GC task manager
     bool TraceGCTaskQueue                          = false           {develop}Trace actions of the GC task queues
     bool TraceGCTaskThread                         = false           {diagnostic}Trace actions of the GC task threads
     bool PrintParallelOldGCPhaseTimes              = false           {product}Print the time taken by each phase in ParallelOldGC (PrintGCDetails must also be enabled)
     bool TraceParallelOldGCMarkingPhase            = false           {develop}Trace marking phase in ParallelOldGC
     bool TraceParallelOldGCSummaryPhase            = false           {develop}Trace summary phase in ParallelOldGC
     bool TraceParallelOldGCCompactionPhase         = false           {develop}Trace compaction phase in ParallelOldGC
     bool TraceParallelOldGCDensePrefix             = false           {develop}Trace dense prefix computation for ParallelOldGC
     bool IgnoreLibthreadGPFault                    = false           {develop}Suppress workaround for libthread GP fault
     bool PrintJNIGCStalls                          = false           {product}Print diagnostic message when GC is stalled by JNI critical section
     bool UseGCLogFileRotation                      = false           {product}Rotate gclog files (for long running applications). It requires -Xloggc:<filename>
    uintx NumberOfGCLogFiles                        = 0               {product}Number of gclog files in rotation (default: 0, no rotation)
    uintx GCLogFileSize                             = 0               {product}GC log file size (default: 0 bytes, no rotation). It requires UseGCLogFileRotation
     bool TraceJVMTIObjectTagging                   = false           {diagnostic}Trace JVMTI object tagging calls
     bool VerifyBeforeIteration                     = false           {diagnostic}Verify memory system before JVMTI iteration
     bool CIPrintCompilerName                       = false           {develop}when CIPrint is active, print the name of the active compiler
     bool CIPrintCompileQueue                       = false           {develop}display the contents of the compile queue whenever a compilation is enqueued
     bool CIPrintRequests                           = false           {develop}display every request for compilation
     bool CITime                                    = false           {product}collect timing information for compilation
     bool CITimeEach                                = false           {develop}display timing information after each successful compilation
     bool CICountOSR                                = false           {develop}use a separate counter when assigning ids to osr compilations
     bool CICompileNatives                          = true            {develop}compile native methods if supported by the compiler
     bool CICompileOSR                              = true            {pd develop}compile on stack replacement methods if supported by the compiler
     bool CIPrintMethodCodes                        = false           {develop}print method bytecodes of the compiled code
     bool CIPrintTypeFlow                           = false           {develop}print the results of ciTypeFlow analysis
     bool CITraceTypeFlow                           = false           {develop}detailed per-bytecode tracing of ciTypeFlow analysis
     intx OSROnlyBCI                                = -1              {develop}OSR only at this bci.  Negative values mean exclude that bci
     intx CICompilerCount                           = 1               {product}Number of compiler threads to run
     intx CompilationPolicyChoice                   = 0               {product}which compilation policy (0/1)
     bool UseStackBanging                           = true            {develop}use stack banging for stack overflow checks (required for proper StackOverflow handling; disable only to measure cost of stackbanging)
     bool UseStrictFP                               = true            {develop}use strict fp if modifier strictfp is set
     bool GenerateSynchronizationCode               = true            {develop}generate locking/unlocking code for synchronized methods and monitors
     bool GenerateCompilerNullChecks                = true            {develop}Generate explicit null checks for loads/stores/calls
     bool GenerateRangeChecks                       = true            {develop}Generate range checks for array accesses
     bool ImplicitNullChecks                        = true            {pd develop}Generate code for implicit null checks
     bool PrintSafepointStatistics                  = false           {product}Print statistics about safepoint synchronization
     intx PrintSafepointStatisticsCount             = 300             {product}Total number of safepoint statistics collected before printing them out
     intx PrintSafepointStatisticsTimeout           = -1              {product}Print safepoint statistics only when safepoint takes more than PrintSafepointSatisticsTimeout in millis
     bool TraceSafepointCleanupTime                 = false           {product}Print the break down of clean up tasks performed during safepoint
     bool Inline                                    = true            {product}Enable inlining
     bool ClipInlining                              = true            {product}Clip inlining if aggregate method exceeds DesiredMethodLimit
     bool UseCHA                                    = true            {develop}Enable CHA
     bool UseTypeProfile                            = true            {product}Check interpreter profile for historically monomorphic calls
     bool TimeCompiler                              = false           {notproduct}Time the compiler
     bool PrintInlining                             = false           {diagnostic}Print inlining optimizations
     bool UsePopCountInstruction                    = false           {product}Use population count instruction
     bool EagerInitialization                       = false           {develop}Eagerly initialize classes if possible
     bool TraceMethodReplacement                    = false           {develop}Print when methods are replaced do to recompilation
     bool PrintMethodFlushing                       = false           {develop}Print the nmethods being flushed
     bool UseRelocIndex                             = false           {develop}Use an index to speed random access to relocations
     bool StressCodeBuffers                         = false           {develop}Exercise code buffer expansion and other rare state changes
     bool DebugNonSafepoints                        = true            {diagnostic}Generate extra debugging information for non-safepoints in nmethods
     bool PrintVMOptions                            = false           {product}Print flags that appeared on the command line
     bool IgnoreUnrecognizedVMOptions               = false           {product}Ignore unrecognized VM options
     bool PrintCommandLineFlags                     = false           {product}Print flags specified on command line or set by ergonomics
     bool PrintFlagsInitial                         = false           {product}Print all VM flags before argument processing and exit VM
     bool PrintFlagsFinal                           = false           {product}Print all VM flags after argument and ergonomic processing
     bool PrintFlagsWithComments                    = false           {notproduct}Print all VM flags with default values and descriptions and exit
     bool SerializeVMOutput                         = true            {diagnostic}Use a mutex to serialize output to tty and LogFile
     bool DisplayVMOutput                           = true            {diagnostic}Display all VM output on the tty, independently of LogVMOutput
     bool LogVMOutput                               = false           {diagnostic}Save VM output to LogFile
    ccstr LogFile                                   =                 {diagnostic}If LogVMOutput or LogCompilation is on, save VM output to this file [default: ./hotspot_pid%p.log] (%p replaced with pid)
    ccstr ErrorFile                                 =                 {product}If an error occurs, save the error data to this file [default: ./hs_err_pid%p.log] (%p replaced with pid)
     bool DisplayVMOutputToStderr                   = false           {product}If DisplayVMOutput is true, display all VM output to stderr
     bool DisplayVMOutputToStdout                   = false           {product}If DisplayVMOutput is true, display all VM output to stdout
     bool UseHeavyMonitors                          = false           {product}use heavyweight instead of lightweight Java monitors
     bool PrintStringTableStatistics                = false           {product}print statistics about the StringTable and SymbolTable
     bool VerifyStringTableAtExit                   = false           {diagnostic}verify StringTable contents at exit
     bool PrintSymbolTableSizeHistogram             = false           {notproduct}print histogram of the symbol table
     bool ExitVMOnVerifyError                       = false           {notproduct}standard exit from VM if bytecode verify error (only in debug mode)
    ccstr AbortVMOnException                        =                 {notproduct}Call fatal if this exception is thrown.  Example: java -XX:AbortVMOnException=java.lang.NullPointerException Foo
    ccstr AbortVMOnExceptionMessage                 =                 {notproduct}Call fatal if the exception pointed by AbortVMOnException has this message
     bool DebugVtables                              = false           {develop}add debugging code to vtable dispatch
     bool PrintVtables                              = false           {develop}print vtables when printing klass
     bool PrintVtableStats                          = false           {notproduct}print vtables stats at end of run
     bool TraceCreateZombies                        = false           {develop}trace creation of zombie nmethods
     bool IgnoreLockingAssertions                   = false           {notproduct}disable locking assertions (for speed)
     bool RangeCheckElimination                     = true            {product}Eliminate range checks
     bool UncommonNullCast                          = true            {pd develop}track occurrences of null in casts; adjust compiler tactics
     bool TypeProfileCasts                          = true            {develop}treat casts like calls for purposes of type profiling
     bool DelayCompilationDuringStartup             = true            {develop}Delay invoking the compiler until main application class is loaded
     bool CompileTheWorld                           = false           {develop}Compile all methods in all classes in bootstrap class path (stress test)
     bool CompileTheWorldPreloadClasses             = true            {develop}Preload all classes used by a class before start loading
     intx CompileTheWorldSafepointInterval          = 100             {notproduct}Force a safepoint every n compiles so sweeper can keep up
     bool FillDelaySlots                            = true            {develop}Fill delay slots (on SPARC only)
     bool TimeLivenessAnalysis                      = false           {develop}Time computation of bytecode liveness analysis
     bool TraceLivenessGen                          = false           {develop}Trace the generation of liveness analysis information
     bool TraceLivenessQuery                        = false           {notproduct}Trace queries of liveness analysis information
     bool CollectIndexSetStatistics                 = false           {notproduct}Collect information about IndexSets
     bool UseLoopSafepoints                         = true            {develop}Generate Safepoint nodes in every loop
     intx FastAllocateSizeLimit                     = 131072          {develop}Inline allocations larger than this in doublewords must go slow
     bool AggressiveOpts                            = false           {product}Enable aggressive optimizations - see arguments.cpp
    uintx TypeProfileLevel                          = 111             {pd product}=XYZ, with Z: Type profiling of arguments at call; Y: Type profiling of return value at call; X: Type profiling of parameters to methods; X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods
     intx TypeProfileArgsLimit                      = 2               {product}max number of call arguments to consider for type profiling
     intx TypeProfileParmsLimit                     = 2               {product}max number of incoming parameters to consider for type profiling, -1 for all
     bool CountCompiledCalls                        = false           {develop}Count method invocations
     bool CountRuntimeCalls                         = false           {notproduct}Count VM runtime calls
     bool CountJNICalls                             = false           {develop}Count jni method invocations
     bool CountJVMCalls                             = false           {notproduct}Count jvm method invocations
     bool CountRemovableExceptions                  = false           {notproduct}Count exceptions that could be replaced by branches due to inlining
     bool ICMissHistogram                           = false           {notproduct}Produce histogram of IC misses
     bool PrintClassStatistics                      = false           {notproduct}Print class statistics at end of run
     bool PrintMethodStatistics                     = false           {notproduct}Print method statistics at end of run
     bool ClearInterpreterLocals                    = false           {develop}Always clear local variables of interpreter activations upon entry
     bool RewriteBytecodes                          = true            {pd product}Allow rewriting of bytecodes (bytecodes are not immutable)
     bool RewriteFrequentPairs                      = true            {pd product}Rewrite frequently used bytecode pairs into a single bytecode
     bool PrintInterpreter                          = false           {diagnostic}Print the generated interpreter code
     bool UseInterpreter                            = true            {product}Use interpreter for non-compiled methods
     bool UseFastSignatureHandlers                  = true            {develop}Use fast signature handlers for native calls
     bool UseLoopCounter                            = true            {product}Increment invocation counter on backward branch
     bool UseFastEmptyMethods                       = true            {product}Use fast method entry code for empty methods
     bool UseFastAccessorMethods                    = true            {product}Use fast method entry code for accessor methods
     bool UseOnStackReplacement                     = true            {pd product}Use on stack replacement, calls runtime if invoc. counter overflows in loop
     bool TraceOnStackReplacement                   = false           {notproduct}Trace on stack replacement
     bool PreferInterpreterNativeStubs              = false           {pd product}Use always interpreter stubs for native methods invoked via interpreter
     bool CountBytecodes                            = false           {develop}Count number of bytecodes executed
     bool PrintBytecodeHistogram                    = false           {develop}Print histogram of the executed bytecodes
     bool PrintBytecodePairHistogram                = false           {develop}Print histogram of the executed bytecode pairs
     bool PrintSignatureHandlers                    = false           {diagnostic}Print code generated for native method signature handlers
     bool VerifyOops                                = false           {develop}Do plausibility checks for oops
     bool CheckUnhandledOops                        = false           {develop}Check for unhandled oops in VM code
     bool VerifyJNIFields                           = true            {develop}Verify jfieldIDs for instance fields
     bool VerifyJNIEnvThread                        = false           {notproduct}Verify JNIEnv.thread == Thread::current() when entering VM from JNI
     bool VerifyFPU                                 = false           {develop}Verify FPU state (check for NaN's, etc.)
     bool VerifyThread                              = false           {develop}Watch the thread register for corruption (SPARC only)
     bool VerifyActivationFrameSize                 = false           {develop}Verify that activation frame didn't become smaller than its minimal size
     bool TraceFrequencyInlining                    = false           {develop}Trace frequency based inlining
     bool InlineIntrinsics                          = true            {pd develop}Inline intrinsics that can be statically resolved
     bool ProfileInterpreter                        = false           {pd product}Profile at the bytecode level during interpretation
     bool ProfileTraps                              = false           {pd develop}Profile deoptimization traps at the bytecode level
     intx ProfileMaturityPercentage                 = 20              {product}number of method invocations/branches (expressed as % of CompileThreshold) before using the method's profile
     bool PrintMethodData                           = false           {develop}Print the results of +ProfileInterpreter at end of run
     bool VerifyDataPointer                         = true            {develop}Verify the method data pointer during interpreter profiling
     bool VerifyCompiledCode                        = false           {develop}Include miscellaneous runtime verifications in nmethod code; default off because it disturbs nmethod size heuristics
     bool CrashGCForDumpingJavaThread               = false           {notproduct}Manually make GC thread crash then dump java stack trace;  Test only
     bool UseCompiler                               = true            {product}Use Just-In-Time compilation
     bool TraceCompilationPolicy                    = false           {develop}Trace compilation policy
     bool TimeCompilationPolicy                     = false           {develop}Time the compilation policy
     bool UseCounterDecay                           = true            {product}Adjust recompilation counters
     intx CounterHalfLifeTime                       = 30              {develop}Half-life time of invocation counters (in seconds)
     intx CounterDecayMinIntervalLength             = 500             {develop}The minimum interval (in milliseconds) between invocation of CounterDecay
     bool AlwaysCompileLoopMethods                  = false           {product}When using recompilation, never interpret methods containing loops
     bool DontCompileHugeMethods                    = true            {product}Do not compile methods > HugeMethodLimit
     bool EstimateArgEscape                         = true            {product}Analyze bytecodes to estimate escape state of arguments
     intx BCEATraceLevel                            = 0               {product}How much tracing to do of bytecode escape analysis estimates
     intx MaxBCEAEstimateLevel                      = 5               {product}Maximum number of nested calls that are analyzed by BC EA
     intx MaxBCEAEstimateSize                       = 150             {product}Maximum bytecode size of a method to be analyzed by BC EA
     intx AllocatePrefetchStyle                     = 1               {product}0 = no prefetch, 1 = prefetch instructions for each allocation, 2 = use TLAB watermark to gate allocation prefetch, 3 = use BIS instruction on Sparc for allocation prefetch
     intx AllocatePrefetchDistance                  = -1              {product}Distance to prefetch ahead of allocation pointer
     intx AllocatePrefetchLines                     = 3               {product}Number of lines to prefetch ahead of array allocation pointer
     intx AllocateInstancePrefetchLines             = 1               {product}Number of lines to prefetch ahead of instance allocation pointer
     intx AllocatePrefetchStepSize                  = 16              {product}Step size in bytes of sequential prefetch instructions
     intx AllocatePrefetchInstr                     = 0               {product}Prefetch instruction to prefetch ahead of allocation pointer
     bool TraceDeoptimization                       = false           {develop}Trace deoptimization
     bool DebugDeoptimization                       = false           {develop}Tracing various information while debugging deoptimization
     intx SelfDestructTimer                         = 0               {product}Will cause VM to terminate after a given time (in minutes) (0 means off)
     intx MaxJavaStackTraceDepth                    = 1024            {product}The maximum number of lines in the stack trace for Java exceptions (0 means all)
     intx GuaranteedSafepointInterval               = 1000            {diagnostic}Guarantee a safepoint (at least) every so many milliseconds (0 means none)
     intx SafepointTimeoutDelay                     = 10000           {product}Delay in milliseconds for option SafepointTimeout
     intx NmethodSweepFraction                      = 16              {product}Number of invocations of sweeper to cover all nmethods
     intx NmethodSweepCheckInterval                 = 5               {product}Compilers wake up every n seconds to possibly sweep nmethods
     intx NmethodSweepActivity                      = 10              {product}Removes cold nmethods from code cache if > 0. Higher values result in more aggressive sweeping
     bool LogSweeper                                = false           {notproduct}Keep a ring buffer of sweeper activity
     intx SweeperLogEntries                         = 1024            {notproduct}Number of records in the ring buffer of sweeper activity
     intx MemProfilingInterval                      = 500             {notproduct}Time between each invocation of the MemProfiler
     intx MallocCatchPtr                            = -1              {develop}Hit breakpoint when mallocing/freeing this pointer
     intx AssertRepeat                              = 1               {notproduct}number of times to evaluate expression in assert (to estimate overhead); only works with -DUSE_REPEATED_ASSERTS
ccstrlist SuppressErrorAt                           =                 {notproduct}List of assertions (file:line) to muzzle
    uintx HandleAllocationLimit                     = 1024            {notproduct}Threshold for HandleMark allocation when +TraceHandleAllocation is used
    uintx TotalHandleAllocationLimit                = 1024            {develop}Threshold for total handle allocation when +TraceHandleAllocation is used
     intx StackPrintLimit                           = 100             {develop}number of stack frames to print in VM-level stack dump
     intx MaxElementPrintSize                       = 256             {notproduct}maximum number of elements to print
     intx MaxSubklassPrintSize                      = 4               {notproduct}maximum number of subklasses to print when printing klass
     intx MaxInlineLevel                            = 9               {product}maximum number of nested calls that are inlined
     intx MaxRecursiveInlineLevel                   = 1               {product}maximum number of nested recursive calls that are inlined
     intx MaxForceInlineLevel                       = 100             {develop}maximum number of nested @ForceInline calls that are inlined
     intx InlineSmallCode                           = 1000            {pd product}Only inline already compiled methods if their code size is less than this
     intx MaxInlineSize                             = 35              {product}The maximum bytecode size of a method to be inlined
     intx FreqInlineSize                            = 325             {pd product}The maximum bytecode size of a frequent method to be inlined
     intx MaxTrivialSize                            = 6               {product}The maximum bytecode size of a trivial method to be inlined
     intx MinInliningThreshold                      = 250             {product}The minimum invocation count a method needs to have to be inlined
     intx MethodHistogramCutoff                     = 100             {develop}The cutoff value for method invocation histogram (+CountCalls)
     intx ProfilerNumberOfInterpretedMethods        = 25              {develop}Number of interpreted methods to show in profile
     intx ProfilerNumberOfCompiledMethods           = 25              {develop}Number of compiled methods to show in profile
     intx ProfilerNumberOfStubMethods               = 25              {develop}Number of stub methods to show in profile
     intx ProfilerNumberOfRuntimeStubNodes          = 25              {develop}Number of runtime stub nodes to show in profile
     intx ProfileIntervalsTicks                     = 100             {product}Number of ticks between printing of interval profile (+ProfileIntervals)
     intx ScavengeALotInterval                      = 1               {notproduct}Interval between which scavenge will occur with +ScavengeALot
     intx FullGCALotInterval                        = 1               {notproduct}Interval between which full gc will occur with +FullGCALot
     intx FullGCALotStart                           = 0               {notproduct}For which invocation to start FullGCAlot
     intx FullGCALotDummies                         = 32768           {notproduct}Dummy object allocated with +FullGCALot, forcing all objects to move
     intx DontYieldALotInterval                     = 10              {develop}Interval between which yields will be dropped (milliseconds)
     intx MinSleepInterval                          = 1               {develop}Minimum sleep() interval (milliseconds) when ConvertSleepToYield is off (used for Solaris)
     intx ProfilerPCTickThreshold                   = 15              {develop}Number of ticks in a PC buckets to be a hotspot
     intx DeoptimizeALotInterval                    = 5               {notproduct}Number of exits until DeoptimizeALot kicks in
     intx ZombieALotInterval                        = 5               {notproduct}Number of exits until ZombieALot kicks in
     intx MallocVerifyInterval                      = 0               {diagnostic}If non-zero, verify C heap after every N calls to malloc/realloc/free
     intx MallocVerifyStart                         = 0               {diagnostic}If non-zero, start verifying C heap after Nth call to malloc/realloc/free
    uintx MallocMaxTestWords                        = 0               {diagnostic}If non-zero, maximum number of words that malloc/realloc can allocate (for testing only)
     intx TypeProfileWidth                          = 2               {product}Number of receiver types to record in call/cast profile
     intx BciProfileWidth                           = 2               {develop}Number of return bci's to record in ret profile
     intx PerMethodRecompilationCutoff              = 400             {product}After recompiling N times, stay in the interpreter (-1=>'Inf')
     intx PerBytecodeRecompilationCutoff            = 200             {product}Per-BCI limit on repeated recompilation (-1=>'Inf')
     intx PerMethodTrapLimit                        = 100             {product}Limit on traps (of one kind) in a method (includes inlines)
     intx PerBytecodeTrapLimit                      = 4               {product}Limit on traps (of one kind) at a particular BCI
     intx InlineFrequencyRatio                      = 20              {develop}Ratio of call site execution to caller method invocation
     intx InlineFrequencyCount                      = 100             {pd develop}Count of call site execution necessary to trigger frequent inlining
     intx InlineThrowCount                          = 50              {develop}Force inlining of interpreted methods that throw this often
     intx InlineThrowMaxSize                        = 200             {develop}Force inlining of throwing methods smaller than this
     intx ProfilerNodeSize                          = 1024            {develop}Size in K to allocate for the Profile Nodes of each thread
     intx PreInflateSpin                            = 10              {pd product}Number of times to spin wait before inflation
    uintx InitialHeapSize                           = 0               {product}Initial heap size (in bytes); zero means use ergonomics
    uintx MaxHeapSize                               = 100663296       {product}Maximum heap size (in bytes)
    uintx OldSize                                   = 4194304         {product}Initial tenured generation size (in bytes)
    uintx NewSize                                   = 1048576         {product}Initial new generation size (in bytes)
    uintx MaxNewSize                                = 4294967295      {product}Maximum new generation size (in bytes), max_uintx means set ergonomically
    uintx PretenureSizeThreshold                    = 0               {product}Maximum size in bytes of objects allocated in DefNew generation; zero means no maximum
    uintx TLABSize                                  = 0               {product}Starting TLAB size (in bytes); zero means set ergonomically
    uintx MinTLABSize                               = 2048            {product}Minimum allowed TLAB size (in bytes)
    uintx TLABAllocationWeight                      = 35              {product}Allocation averaging weight
    uintx TLABWasteTargetPercent                    = 1               {product}Percentage of Eden that can be wasted
    uintx TLABRefillWasteFraction                   = 64              {product}Maximum TLAB waste at a refill (internal fragmentation)
    uintx TLABWasteIncrement                        = 4               {product}Increment allowed waste at slow allocation
    uintx SurvivorRatio                             = 8               {product}Ratio of eden/survivor space size
    uintx NewRatio                                  = 2               {product}Ratio of old/new generation sizes
    uintx NewSizeThreadIncrease                     = 4096            {pd product}Additional size added to desired new generation size per non-daemon thread (in bytes)
    uintx MetaspaceSize                             = 12582912        {pd product}Initial size of Metaspaces (in bytes)
    uintx MaxMetaspaceSize                          = 4294967295      {product}Maximum size of Metaspaces (in bytes)
    uintx CompressedClassSpaceSize                  = 1073741824      {product}Maximum size of class area in Metaspace when compressed class pointers are used
    uintx MinHeapFreeRatio                          = 40              {product}The minimum percentage of heap free after GC to avoid expansion. For most GCs this applies to the old generation. In G1 it applies to the whole heap. Not supported by ParallelGC.
    uintx MaxHeapFreeRatio                          = 70              {product}The maximum percentage of heap free after GC to avoid shrinking. For most GCs this applies to the old generation. In G1 it applies to the whole heap. Not supported by ParallelGC.
     intx SoftRefLRUPolicyMSPerMB                   = 1000            {product}Number of milliseconds per MB of free space in the heap
    uintx MinHeapDeltaBytes                         = 131072          {product}The minimum change in heap space due to GC (in bytes)
    uintx MinMetaspaceExpansion                     = 262144          {product}The minimum expansion of Metaspace (in bytes)
    uintx MinMetaspaceFreeRatio                     = 40              {product}The minimum percentage of Metaspace free after GC to avoid expansion
    uintx MaxMetaspaceFreeRatio                     = 70              {product}The maximum percentage of Metaspace free after GC to avoid shrinking
    uintx MaxMetaspaceExpansion                     = 4194304         {product}The maximum expansion of Metaspace without full GC (in bytes)
    uintx QueuedAllocationWarningCount              = 0               {product}Number of times an allocation that queues behind a GC will retry before printing a warning
    uintx VerifyGCStartAt                           = 0               {diagnostic}GC invoke count where +VerifyBefore/AfterGC kicks in
     intx VerifyGCLevel                             = 0               {diagnostic}Generation level at which to start +VerifyBefore/AfterGC
    uintx MaxTenuringThreshold                      = 15              {product}Maximum value for tenuring threshold
    uintx InitialTenuringThreshold                  = 7               {product}Initial value for tenuring threshold
    uintx TargetSurvivorRatio                       = 50              {product}Desired percentage of survivor space used after scavenge
    uintx MarkSweepDeadRatio                        = 5               {product}Percentage (0-100) of the old gen allowed as dead wood. Serial mark sweep treats this as both the minimum and maximum value. CMS uses this value only if it falls back to mark sweep. Par compact uses a variable scale based on the density of the generation and treats this as the maximum value when the heap is either completely full or completely empty.  Par compact also has a smaller default value; see arguments.cpp.
    uintx MarkSweepAlwaysCompactCount               = 4               {product}How often should we fully compact the heap (ignoring the dead space parameters)
     intx PrintCMSStatistics                        = 0               {product}Statistics for CMS
     bool PrintCMSInitiationStatistics              = false           {product}Statistics for initiating a CMS collection
     intx PrintFLSStatistics                        = 0               {product}Statistics for CMS' FreeListSpace
     intx PrintFLSCensus                            = 0               {product}Census for CMS' FreeListSpace
    uintx GCExpandToAllocateDelayMillis             = 0               {develop}Delay between expansion and allocation (in milliseconds)
    uintx GCWorkerDelayMillis                       = 0               {develop}Delay in scheduling GC workers (in milliseconds)
     intx DeferThrSuspendLoopCount                  = 4000            {product}(Unstable) Number of times to iterate in safepoint loop before blocking VM threads 
     intx DeferPollingPageLoopCount                 = -1              {product}(Unsafe,Unstable) Number of iterations in safepoint loop before changing safepoint polling page to RO 
     intx SafepointSpinBeforeYield                  = 2000            {product}(Unstable)
     bool PSChunkLargeArrays                        = true            {product}Process large arrays in chunks
    uintx GCDrainStackTargetSize                    = 64              {product}Number of entries we will try to leave on the stack during parallel gc
     intx StackYellowPages                          = 3               {pd product}Number of yellow zone (recoverable overflows) pages
     intx StackRedPages                             = 1               {pd product}Number of red zone (unrecoverable overflows) pages
     intx StackShadowPages                          = 9               {pd product}Number of shadow zone (for overflow checking) pages this should exceed the depth of the VM and native call stack
     intx ThreadStackSize                           = 0               {pd product}Thread Stack Size (in Kbytes)
     intx VMThreadStackSize                         = 0               {pd product}Non-Java Thread Stack Size (in Kbytes)
     intx CompilerThreadStackSize                   = 1024            {pd product}Compiler Thread Stack Size (in Kbytes)
    uintx JVMInvokeMethodSlack                      = 8192            {pd develop}Stack space (bytes) required for JVM_InvokeMethod to complete
    uintx ThreadSafetyMargin                        = 52428800        {product}Thread safety margin is used on fixed-stack LinuxThreads (on Linux/x86 only) to prevent heap-stack collision. Set to 0 to disable this feature
    uintx CodeCacheSegmentSize                      = 64              {develop}Code cache segment size (in bytes) - smallest unit of allocation
     intx CodeEntryAlignment                        = 16              {pd develop}Code entry alignment for generated code (in bytes)
     intx OptoLoopAlignment                         = 16              {pd product}Align inner loops to zero relative to this modulus
    uintx InitialCodeCacheSize                      = 163840          {pd product}Initial code cache size (in bytes)
    uintx CodeCacheMinimumUseSpace                  = 409600          {pd develop}Minimum code cache size (in bytes) required to start VM.
    uintx ReservedCodeCacheSize                     = 33554432        {pd product}Reserved code cache size (in bytes) - maximum code cache size
    uintx CodeCacheMinimumFreeSpace                 = 512000          {product}When less than X space left, we stop compiling
    uintx CodeCacheExpansionSize                    = 32768           {pd product}Code cache expansion size (in bytes)
    uintx CodeCacheMinBlockLength                   = 1               {pd develop}Minimum number of segments in a code cache block
     bool ExitOnFullCodeCache                       = false           {notproduct}Exit the VM if we fill the code cache
     bool UseCodeCacheFlushing                      = true            {product}Remove cold/old nmethods from the code cache
     intx BinarySwitchThreshold                     = 5               {develop}Minimal number of lookupswitch entries for rewriting to binary switch
     intx StopInterpreterAt                         = 0               {develop}Stop interpreter execution at specified bytecode number
     intx TraceBytecodesAt                          = 0               {develop}Trace bytecodes starting with specified bytecode number
     intx CIStart                                   = 0               {develop}The id of the first compilation to permit
     intx CIStop                                    = -1              {develop}The id of the last compilation to permit
     intx CIStartOSR                                = 0               {develop}The id of the first osr compilation to permit (CICountOSR must be on)
     intx CIStopOSR                                 = -1              {develop}The id of the last osr compilation to permit (CICountOSR must be on)
     intx CIBreakAtOSR                              = -1              {develop}The id of osr compilation to break at
     intx CIBreakAt                                 = -1              {develop}The id of compilation to break at
ccstrlist CompileOnly                               =                 {product}List of methods (pkg/class.name) to restrict compilation to
    ccstr CompileCommandFile                        =                 {product}Read compiler commands from this file [.hotspot_compiler]
ccstrlist CompileCommand                            =                 {product}Prepend to .hotspot_compiler; e.g. log,java/lang/String.<init>
     bool ReplayCompiles                            = false           {develop}Enable replay of compilations from ReplayDataFile
    ccstr ReplayDataFile                            =                 {product}File containing compilation replay information[default: ./replay_pid%p.log] (%p replaced with pid)
     intx ReplaySuppressInitializers                = 2               {develop}Control handling of class initialization during replay: 0 - don't do anything special; 1 - treat all class initializers as empty; 2 - treat class initializers for application classes as empty; 3 - allow all class initializers to run during bootstrap but     pretend they are empty after starting replay
     bool ReplayIgnoreInitErrors                    = false           {develop}Ignore exceptions thrown during initialization for replay
     bool DumpReplayDataOnError                     = true            {product}Record replay data for crashing compiler threads
     bool CICompilerCountPerCPU                     = false           {product}1 compiler thread for log(N CPUs)
     intx CIFireOOMAt                               = -1              {develop}Fire OutOfMemoryErrors throughout CI for testing the compiler (non-negative value throws OOM after this many CI accesses in each compile)
     intx CICrashAt                                 = -1              {notproduct}id of compilation to trigger assert in compiler thread for the purpose of testing, e.g. generation of replay data
     bool CIObjectFactoryVerify                     = false           {notproduct}enable potentially expensive verification in ciObjectFactory
     bool UseThreadPriorities                       = true            {pd product}Use native thread priorities
     intx ThreadPriorityPolicy                      = 0               {product}0 : Normal.                                                         VM chooses priorities that are appropriate for normal           applications. On Solaris NORM_PRIORITY and above are mapped     to normal native priority. Java priorities below     NORM_PRIORITY map to lower native priority values. On           Windows applications are allowed to use higher native           priorities. However, with ThreadPriorityPolicy=0, VM will       not use the highest possible native priority,                   THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with         system threads. On Linux thread priorities are ignored          because the OS does not support static priority in              SCHED_OTHER scheduling class which is the only choice for       non-root, non-realtime applications.                        1 : Aggressive.                                                     Java thread priorities map over to the entire range of          native thread priorities. Higher Java thread priorities map     to higher native thread priorities. This policy should be       used with care, as sometimes it can cause performance           degradation in the application and/or the entire system. On     Linux this policy requires root privilege.
     bool ThreadPriorityVerbose                     = false           {product}Print priority changes
     intx DefaultThreadPriority                     = -1              {product}The native priority at which threads run if not elsewhere specified (-1 means no change)
     intx CompilerThreadPriority                    = -1              {product}The native priority at which compiler threads should run (-1 means no change)
     intx VMThreadPriority                          = -1              {product}The native priority at which the VM thread should run (-1 means no change)
     bool CompilerThreadHintNoPreempt               = true            {product}(Solaris only) Give compiler threads an extra quanta
     bool VMThreadHintNoPreempt                     = false           {product}(Solaris only) Give VM thread an extra quanta
     intx JavaPriority1_To_OSPriority               = -1              {product}Map Java priorities to OS priorities
     intx JavaPriority2_To_OSPriority               = -1              {product}Map Java priorities to OS priorities
     intx JavaPriority3_To_OSPriority               = -1              {product}Map Java priorities to OS priorities
     intx JavaPriority4_To_OSPriority               = -1              {product}Map Java priorities to OS priorities
     intx JavaPriority5_To_OSPriority               = -1              {product}Map Java priorities to OS priorities
     intx JavaPriority6_To_OSPriority               = -1              {product}Map Java priorities to OS priorities
     intx JavaPriority7_To_OSPriority               = -1              {product}Map Java priorities to OS priorities
     intx JavaPriority8_To_OSPriority               = -1              {product}Map Java priorities to OS priorities
     intx JavaPriority9_To_OSPriority               = -1              {product}Map Java priorities to OS priorities
     intx JavaPriority10_To_OSPriority              = -1              {product}Map Java priorities to OS priorities
     intx CompileTheWorldStartAt                    = 1               {notproduct}First class to consider when using +CompileTheWorld
     intx CompileTheWorldStopAt                     = 2147483647      {notproduct}Last class to consider when using +CompileTheWorld
     intx NewCodeParameter                          = 0               {develop}Testing Only: Create a dedicated integer parameter before putback
     intx MinOopMapAllocation                       = 8               {develop}Minimum number of OopMap entries in an OopMapSet
     intx LongCompileThreshold                      = 50              {develop}Used with +TraceLongCompiles
     intx StarvationMonitorInterval                 = 200             {product}Pause between each check (in milliseconds)
     intx CompileThreshold                          = 1500            {pd product}number of interpreted method invocations before (re-)compiling
     intx BackEdgeThreshold                         = 100000          {pd product}Interpreter Back edge threshold at which an OSR compilation is invoked
     intx Tier0InvokeNotifyFreqLog                  = 7               {product}Interpreter (tier 0) invocation notification frequency
     intx Tier2InvokeNotifyFreqLog                  = 11              {product}C1 without MDO (tier 2) invocation notification frequency
     intx Tier3InvokeNotifyFreqLog                  = 10              {product}C1 with MDO profiling (tier 3) invocation notification frequency
     intx Tier23InlineeNotifyFreqLog                = 20              {product}Inlinee invocation (tiers 2 and 3) notification frequency
     intx Tier0BackedgeNotifyFreqLog                = 10              {product}Interpreter (tier 0) invocation notification frequency
     intx Tier2BackedgeNotifyFreqLog                = 14              {product}C1 without MDO (tier 2) invocation notification frequency
     intx Tier3BackedgeNotifyFreqLog                = 13              {product}C1 with MDO profiling (tier 3) invocation notification frequency
     intx Tier2CompileThreshold                     = 0               {product}threshold at which tier 2 compilation is invoked
     intx Tier2BackEdgeThreshold                    = 0               {product}Back edge threshold at which tier 2 compilation is invoked
     intx Tier3InvocationThreshold                  = 200             {product}Compile if number of method invocations crosses this threshold
     intx Tier3MinInvocationThreshold               = 100             {product}Minimum invocation to compile at tier 3
     intx Tier3CompileThreshold                     = 2000            {product}Threshold at which tier 3 compilation is invoked (invocation minimum must be satisfied
     intx Tier3BackEdgeThreshold                    = 60000           {product}Back edge threshold at which tier 3 OSR compilation is invoked
     intx Tier4InvocationThreshold                  = 5000            {product}Compile if number of method invocations crosses this threshold
     intx Tier4MinInvocationThreshold               = 600             {product}Minimum invocation to compile at tier 4
     intx Tier4CompileThreshold                     = 15000           {product}Threshold at which tier 4 compilation is invoked (invocation minimum must be satisfied
     intx Tier4BackEdgeThreshold                    = 40000           {product}Back edge threshold at which tier 4 OSR compilation is invoked
     intx Tier3DelayOn                              = 5               {product}If C2 queue size grows over this amount per compiler thread stop compiling at tier 3 and start compiling at tier 2
     intx Tier3DelayOff                             = 2               {product}If C2 queue size is less than this amount per compiler thread allow methods compiled at tier 2 transition to tier 3
     intx Tier3LoadFeedback                         = 5               {product}Tier 3 thresholds will increase twofold when C1 queue size reaches this amount per compiler thread
     intx Tier4LoadFeedback                         = 3               {product}Tier 4 thresholds will increase twofold when C2 queue size reaches this amount per compiler thread
     intx TieredCompileTaskTimeout                  = 50              {product}Kill compile task if method was not used within given timeout in milliseconds
     intx TieredStopAtLevel                         = 4               {product}Stop at given compilation level
     intx Tier0ProfilingStartPercentage             = 200             {product}Start profiling in interpreter if the counters exceed tier 3 thresholds by the specified percentage
    uintx IncreaseFirstTierCompileThresholdAt       = 50              {product}Increase the compile threshold for C1 compilation if the code cache is filled by the specified percentage
     intx TieredRateUpdateMinTime                   = 1               {product}Minimum rate sampling interval (in milliseconds)
     intx TieredRateUpdateMaxTime                   = 25              {product}Maximum rate sampling interval (in milliseconds)
     bool TieredCompilation                         = false           {pd product}Enable tiered compilation
     bool PrintTieredEvents                         = false           {product}Print tiered events notifications
     intx OnStackReplacePercentage                  = 933             {pd product}NON_TIERED number of method invocations/branches (expressed as % of CompileThreshold) before (re-)compiling OSR code
     intx InterpreterProfilePercentage              = 33              {product}NON_TIERED number of method invocations/branches (expressed as % of CompileThreshold) before profiling in the interpreter
     intx MaxRecompilationSearchLength              = 10              {develop}The maximum number of frames to inspect when searching for recompilee
     intx MaxInterpretedSearchLength                = 3               {develop}The maximum number of interpreted frames to skip when searching for recompilee
     intx DesiredMethodLimit                        = 8000            {develop}The desired maximum method size (in bytecodes) after inlining
     intx HugeMethodLimit                           = 8000            {develop}Don't compile methods larger than this if +DontCompileHugeMethods
     bool UseNewReflection                          = true            {develop}Temporary flag for transition to reflection based on dynamic bytecode generation in 1.4; can no longer be turned off in 1.4 JDK, and is unneeded in 1.3 JDK, but marks most places VM changes were needed
     bool VerifyReflectionBytecodes                 = false           {develop}Force verification of 1.4 reflection bytecodes. Does not work in situations like that described in 4486457 or for constructors generated for serialization, so can not be enabled in product.
     bool ReflectionWrapResolutionErrors            = true            {product}Temporary flag for transition to AbstractMethodError wrapped in InvocationTargetException. See 6531596
     intx FastSuperclassLimit                       = 8               {develop}Depth of hardwired instanceof accelerator array
    uintx MaxDirectMemorySize                       = 0               {product}Maximum total size of NIO direct-buffer allocations
     bool UseNewCode                                = false           {diagnostic}Testing Only: Use the new version while testing
     bool UseNewCode2                               = false           {diagnostic}Testing Only: Use the new version while testing
     bool UseNewCode3                               = false           {diagnostic}Testing Only: Use the new version while testing
     bool UsePerfData                               = true            {product}Flag to disable jvmstat instrumentation for performance testing and problem isolation purposes
     bool PerfDataSaveToFile                        = false           {product}Save PerfData memory to hsperfdata_<pid> file on exit
    ccstr PerfDataSaveFile                          =                 {product}Save PerfData memory to the specified absolute pathname. The string %p in the file name (if present) will be replaced by pid
     intx PerfDataSamplingInterval                  = 50              {product}Data sampling interval (in milliseconds)
     bool PerfTraceDataCreation                     = false           {develop}Trace creation of Performance Data Entries
     bool PerfTraceMemOps                           = false           {develop}Trace PerfMemory create/attach/detach calls
     bool PerfDisableSharedMem                      = false           {product}Store performance data in standard memory
     intx PerfDataMemorySize                        = 32768           {product}Size of performance data memory region. Will be rounded up to a multiple of the native os page size.
     intx PerfMaxStringConstLength                  = 1024            {product}Maximum PerfStringConstant string length before truncation
     bool PerfAllowAtExitRegistration               = false           {product}Allow registration of atexit() methods
     bool PerfBypassFileSystemCheck                 = false           {product}Bypass Win32 file system criteria checks (Windows Only)
     intx UnguardOnExecutionViolation               = 0               {product}Unguard page and retry on no-execute fault (Win32 only) 0=off, 1=conservative, 2=aggressive
     bool ManagementServer                          = false           {product}Create JMX Management Server
     bool DisableAttachMechanism                    = false           {product}Disable mechanism that allows tools to attach to this VM
     bool StartAttachListener                       = false           {product}Always start Attach Listener at VM startup
     bool PrintConcurrentLocks                      = false           {manageable}Print java.util.concurrent locks in thread dump
     bool TransmitErrorReport                       = false           {product}Enable error report transmission on erroneous termination
    ccstr ErrorReportServer                         =                 {product}Override built-in error report server address
     bool UseSharedSpaces                           = true            {product}Use shared spaces for metadata
     bool RequireSharedSpaces                       = false           {product}Require shared spaces for metadata
     bool DumpSharedSpaces                          = false           {product}Special mode: JVM reads a class list, loads classes, builds shared spaces, and dumps the shared spaces to a file to be used in future JVM runs
     bool PrintSharedSpaces                         = false           {product}Print usage of shared spaces
    uintx SharedReadWriteSize                       = 12582912        {product}Size of read-write space for metadata (in bytes)
    uintx SharedReadOnlySize                        = 12582912        {product}Size of read-only space for metadata (in bytes)
    uintx SharedMiscDataSize                        = 2097152         {product}Size of the shared miscellaneous data area (in bytes)
    uintx SharedMiscCodeSize                        = 122880          {product}Size of the shared miscellaneous code area (in bytes)
    uintx SharedBaseAddress                         = 0               {product}Address to allocate shared memory region for class data
     bool EnableInvokeDynamic                       = true            {diagnostic}support JSR 292 (method handles, invokedynamic, anonymous classes
     bool PrintMethodHandleStubs                    = false           {diagnostic}Print generated stub code for method handles
     bool TraceMethodHandles                        = false           {develop}trace internal method handle operations
     bool VerifyMethodHandles                       = true            {diagnostic}perform extra checks when constructing method handles
     bool ShowHiddenFrames                          = false           {diagnostic}show method handle implementation frames (usually hidden)
     bool TraceInvokeDynamic                        = false           {develop}trace internal invoke dynamic operations
     bool PauseAtStartup                            = false           {diagnostic}Causes the VM to pause at startup time and wait for the pause file to be removed (default: ./vm.paused.<pid>)
    ccstr PauseAtStartupFile                        =                 {diagnostic}The file to create and for whose removal to await when pausing at startup. (default: ./vm.paused.<pid>)
     bool PauseAtExit                               = false           {diagnostic}Pause and wait for keypress on exit if a debugger is attached
     bool ExtendedDTraceProbes                      = false           {product}Enable performance-impacting dtrace probes
     bool DTraceMethodProbes                        = false           {product}Enable dtrace probes for method-entry and method-exit
     bool DTraceAllocProbes                         = false           {product}Enable dtrace probes for object allocation
     bool DTraceMonitorProbes                       = false           {product}Enable dtrace probes for monitor events
     bool RelaxAccessControlCheck                   = false           {product}Relax the access control checks in the verifier
     bool PrintDTraceDOF                            = false           {diagnostic}Print the DTrace DOF passed to the system for JSDT probes
    uintx StringTableSize                           = 1009            {product}Number of buckets in the interned String table
     bool TraceDefaultMethods                       = false           {develop}Trace the default method processing steps
     bool VerifyGenericSignatures                   = false           {develop}Abort VM on erroneous or inconsistent generic signatures
     bool UseVMInterruptibleIO                      = false           {product}(Unstable, Solaris-specific) Thread interrupt before or with EINTR for I/O operations results in OS_INTRPT. The default value of this flag is true for JDK 6 and earlier
     bool WhiteBoxAPI                               = false           {diagnostic}Enable internal testing APIs
     bool PrintGCCause                              = true            {product}Include GC cause in GC logging
     bool AllowNonVirtualCalls                      = false           {product}Obey the ACC_SUPER flag and allow invokenonvirtual calls
    ccstr SharedArchiveFile                         =                 {diagnostic}Override the default location of the CDS archive file
     bool EnableTracing                             = false           {product}Enable event-based tracing
     bool UseLockedTracing                          = false           {product}Use locked-tracing when doing event-based tracing
     bool UseUTCFileTimestamp                       = true            {product}Adjust the timestamp returned from stat() to be UTC
    uintx G1ConfidencePercent                       = 50              {product}Confidence level for MMU/pause predictions
     intx G1MarkingOverheadPercent                  = 0               {develop}Overhead of concurrent marking
     intx G1MarkingVerboseLevel                     = 0               {develop}Level (0-4) of verboseness of the marking code
     bool G1PrintReachableAtInitialMark             = false           {develop}Reachable object dump at the initial mark pause
     bool G1VerifyDuringGCPrintReachable            = false           {develop}If conc mark verification fails, dump reachable objects
    ccstr G1PrintReachableBaseFile                  =                 {develop}The base file name for the reachable object dumps
     bool G1TraceMarkStackOverflow                  = false           {develop}If true, extra debugging code for CM restart for ovflw.
     bool G1TraceHeapRegionRememberedSet            = false           {develop}Enables heap region remembered set debug logs
     bool G1SummarizeConcMark                       = false           {diagnostic}Summarize concurrent mark info
     bool G1SummarizeRSetStats                      = false           {diagnostic}Summarize remembered set processing info
     intx G1SummarizeRSetStatsPeriod                = 0               {diagnostic}The period (in number of GCs) at which we will generate update buffer processing info (0 means do not periodically generate this info); it also requires -XX:+G1SummarizeRSetStats
     bool G1TraceConcRefinement                     = false           {diagnostic}Trace G1 concurrent refinement
   double G1ConcMarkStepDurationMillis              = 10.000000       {product}Target duration of individual concurrent marking steps in milliseconds.
     intx G1RefProcDrainInterval                    = 10              {product}The number of discovered reference objects to process before draining concurrent marking work queues.
     intx G1SATBBufferSize                          = 1024            {product}Number of entries in an SATB log buffer.
     intx G1SATBProcessCompletedThreshold           = 20              {develop}Number of completed buffers that triggers log processing.
    uintx G1SATBBufferEnqueueingThresholdPercent    = 60              {product}Before enqueueing them, each mutator thread tries to do some filtering on the SATB buffers it generates. If post-filtering the percentage of retained entries is over this threshold the buffer will be enqueued for processing. A value of 0 specifies that mutator threads should not do such filtering.
     bool G1SATBPrintStubs                          = false           {develop}If true, print generated stubs for the SATB barrier
     bool G1RSBarrierRegionFilter                   = true            {develop}If true, generate region filtering code in RS barrier
     bool G1DeferredRSUpdate                        = true            {develop}If true, use deferred RS updates
     bool G1RSLogCheckCardTable                     = false           {develop}If true, verify that no dirty cards remain after RS log processing.
     bool G1PrintRegionLivenessInfo                 = false           {diagnostic}Prints the liveness information for all regions in the heap at the end of a marking cycle.
     intx G1UpdateBufferSize                        = 256             {product}Size of an update buffer
     intx G1ConcRefinementYellowZone                = 0               {product}Number of enqueued update buffers that will trigger concurrent processing. Will be selected ergonomically by default.
     intx G1ConcRefinementRedZone                   = 0               {product}Maximum number of enqueued update buffers before mutator threads start processing new ones instead of enqueueing them. Will be selected ergonomically by default. Zero will disable concurrent processing.
     intx G1ConcRefinementGreenZone                 = 0               {product}The number of update buffers that are left in the queue by the concurrent processing threads. Will be selected ergonomically by default.
     intx G1ConcRefinementServiceIntervalMillis     = 300             {product}The last concurrent refinement thread wakes up every specified number of milliseconds to do miscellaneous work.
     intx G1ConcRefinementThresholdStep             = 0               {product}Each time the rset update queue increases by this amount activate the next refinement thread if available. Will be selected ergonomically by default.
     intx G1RSetUpdatingPauseTimePercent            = 10              {product}A target percentage of time that is allowed to be spend on process RS update buffers during the collection pause.
     bool G1UseAdaptiveConcRefinement               = true            {product}Select green, yellow and red zones adaptively to meet the the pause requirements.
    uintx G1ConcRSLogCacheSize                      = 10              {product}Log base 2 of the length of conc RS hot-card cache.
    uintx G1ConcRSHotCardLimit                      = 4               {product}The threshold that defines (>=) a hot card.
     intx G1RSetRegionEntriesBase                   = 256             {develop}Max number of regions in a fine-grain table per MB.
     intx G1RSetRegionEntries                       = 0               {product}Max number of regions for which we keep bitmaps.Will be set ergonomically by default
     intx G1RSetSparseRegionEntriesBase             = 4               {develop}Max number of entries per region in a sparse table per MB.
     intx G1RSetSparseRegionEntries                 = 0               {product}Max number of entries per region in a sparse table.Will be set ergonomically by default.
     bool G1RecordHRRSOops                          = false           {develop}When true, record recent calls to rem set operations.
     bool G1RecordHRRSEvents                        = false           {develop}When true, record recent calls to rem set operations.
     intx G1MaxVerifyFailures                       = -1              {develop}The maximum number of verification failrues to print.  -1 means print all.
     bool G1ScrubRemSets                            = true            {develop}When true, do RS scrubbing after cleanup.
     bool G1RSScrubVerbose                          = false           {develop}When true, do RS scrubbing with verbose output.
     bool G1YoungSurvRateVerbose                    = false           {develop}print out the survival rate of young regions according to age.
     intx G1YoungSurvRateNumRegionsSummary          = 0               {develop}the number of regions for which we'll print a surv rate summary.
    uintx G1ReservePercent                          = 10              {product}It determines the minimum reserve we should have in the heap to minimize the probability of promotion failure.
     bool G1PrintHeapRegions                        = false           {diagnostic}If set G1 will print information on which regions are being allocated and which are reclaimed.
     bool G1HRRSUseSparseTable                      = true            {develop}When true, use sparse table to save space.
     bool G1HRRSFlushLogBuffersOnVerify             = false           {develop}Forces flushing of log buffers before verification.
     bool G1FailOnFPError                           = false           {develop}When set, G1 will fail when it encounters an FP 'error', so as to allow debugging
    uintx G1HeapRegionSize                          = 0               {product}Size of the G1 regions.
    uintx G1ConcRefinementThreads                   = 0               {product}If non-0 is the number of parallel rem set update threads, otherwise the value is determined ergonomically.
     bool G1VerifyCTCleanup                         = false           {develop}Verify card table cleanup.
    uintx G1RSetScanBlockSize                       = 64              {product}Size of a work unit of cards claimed by a worker threadduring RSet scanning.
    uintx G1SecondaryFreeListAppendLength           = 5               {develop}The number of regions we will add to the secondary free list at every append operation
     bool G1ConcRegionFreeingVerbose                = false           {develop}Enables verboseness during concurrent region freeing
     bool G1StressConcRegionFreeing                 = false           {develop}It stresses the concurrent region freeing operation
    uintx G1StressConcRegionFreeingDelayMillis      = 0               {develop}Artificial delay during concurrent region freeing
    uintx G1DummyRegionsPerGC                       = 0               {develop}The number of dummy regions G1 will allocate at the end of each evacuation pause in order to artificially fill up the heap and stress the marking implementation.
     bool G1ExitOnExpansionFailure                  = false           {develop}Raise a fatal VM exit out of memory failure in the event  that heap expansion fails due to running out of swap.
    uintx G1ConcMarkForceOverflow                   = 0               {develop}The number of times we'll force an overflow during concurrent marking
    uintx G1HeapWastePercent                        = 10              {product}Amount of space, expressed as a percentage of the heap size, that G1 is willing not to collect to avoid expensive GCs.
    uintx G1MixedGCCountTarget                      = 8               {product}The target number of mixed GCs after a marking cycle.
     bool G1EvacuationFailureALot                   = false           {notproduct}Force use of evacuation failure handling during certain evacuation pauses
    uintx G1EvacuationFailureALotCount              = 1000            {develop}Number of successful evacuations between evacuation failures occurring at object copying
    uintx G1EvacuationFailureALotInterval           = 5               {develop}Total collections between forced triggering of evacuation failures
     bool G1EvacuationFailureALotDuringConcMark     = true            {develop}Force use of evacuation failure handling during evacuation pauses when marking is in progress
     bool G1EvacuationFailureALotDuringInitialMark  = true            {develop}Force use of evacuation failure handling during initial mark evacuation pauses
     bool G1EvacuationFailureALotDuringYoungGC      = true            {develop}Force use of evacuation failure handling during young evacuation pauses
     bool G1EvacuationFailureALotDuringMixedGC      = true            {develop}Force use of evacuation failure handling during mixed evacuation pauses
     bool G1VerifyRSetsDuringFullGC                 = false           {diagnostic}If true, perform verification of each heap region's remembered set when verifying the heap during a full GC.
     bool G1VerifyHeapRegionCodeRoots               = false           {diagnostic}Verify the code root lists attached to each heap region.
     bool PrintC1Statistics                         = false           {C1 notproduct}Print Compiler1 statistics
     bool PrintInitialBlockList                     = false           {C1 notproduct}Print block list of BlockListBuilder
     bool PrintCFG                                  = false           {C1 notproduct}Print control flow graph after each change
     bool PrintCFG0                                 = false           {C1 notproduct}Print control flow graph after construction
     bool PrintCFG1                                 = false           {C1 notproduct}Print control flow graph after optimizations
     bool PrintCFG2                                 = false           {C1 notproduct}Print control flow graph before code generation
     bool PrintIRDuringConstruction                 = false           {C1 notproduct}Print IR as it's being constructed (helpful for debugging frontend)
     bool PrintPhiFunctions                         = false           {C1 notproduct}Print phi functions when they are created and simplified
     bool PrintIR                                   = false           {C1 notproduct}Print full intermediate representation after each change
     bool PrintIR0                                  = false           {C1 notproduct}Print full intermediate representation after construction
     bool PrintIR1                                  = false           {C1 notproduct}Print full intermediate representation after optimizations
     bool PrintIR2                                  = false           {C1 notproduct}Print full intermediate representation before code generation
     bool PrintSimpleStubs                          = false           {C1 notproduct}Print SimpleStubs
     bool UseC1Optimizations                        = true            {C1 develop}Turn on C1 optimizations
     bool SelectivePhiFunctions                     = true            {C1 develop}create phi functions at loop headers only when necessary
     bool OptimizeIfOps                             = true            {C1 develop}Optimize multiple IfOps
     bool DoCEE                                     = true            {C1 develop}Do Conditional Expression Elimination to simplify CFG
     bool PrintCEE                                  = false           {C1 develop}Print Conditional Expression Elimination
     bool UseLocalValueNumbering                    = true            {C1 develop}Use Local Value Numbering (embedded in GraphBuilder)
     bool UseGlobalValueNumbering                   = true            {C1 develop}Use Global Value Numbering (separate phase)
     bool UseLoopInvariantCodeMotion                = true            {C1 product}Simple loop invariant code motion for short loops during GVN
     bool TracePredicateFailedTraps                 = false           {C1 develop}trace runtime traps caused by predicate failure
     bool StressLoopInvariantCodeMotion             = false           {C1 develop}stress loop invariant code motion
     bool TraceRangeCheckElimination                = false           {C1 develop}Trace Range Check Elimination
     bool AssertRangeCheckElimination               = false           {C1 develop}Assert Range Check Elimination
     bool StressRangeCheckElimination               = false           {C1 develop}stress Range Check Elimination
     bool PrintValueNumbering                       = false           {C1 develop}Print Value Numbering
     intx ValueMapInitialSize                       = 11              {C1 product}Initial size of a value map
     intx ValueMapMaxLoopSize                       = 8               {C1 product}maximum size of a loop optimized by global value numbering
     bool EliminateBlocks                           = true            {C1 develop}Eliminate unneccessary basic blocks
     bool PrintBlockElimination                     = false           {C1 develop}Print basic block elimination
     bool EliminateNullChecks                       = true            {C1 develop}Eliminate unneccessary null checks
     bool PrintNullCheckElimination                 = false           {C1 develop}Print null check elimination
     bool EliminateFieldAccess                      = true            {C1 develop}Optimize field loads and stores
     bool InlineMethodsWithExceptionHandlers        = true            {C1 develop}Inline methods containing exception handlers (NOTE: does not work with current backend)
     bool InlineSynchronizedMethods                 = true            {C1 product}Inline synchronized methods
     bool InlineNIOCheckIndex                       = true            {C1 develop}Intrinsify java.nio.Buffer.checkIndex
     bool CanonicalizeNodes                         = true            {C1 develop}Canonicalize graph nodes
     bool PrintCanonicalization                     = false           {C1 develop}Print graph node canonicalization
     bool UseTableRanges                            = true            {C1 develop}Faster versions of lookup table using ranges
     bool RoundFPResults                            = true            {C1 pd develop}Indicates whether rounding is needed for floating point results
     intx NestedInliningSizeRatio                   = 90              {C1 develop}Percentage of prev. allowed inline size in recursive inlining
     bool PrintIRWithLIR                            = false           {C1 notproduct}Print IR instructions with generated LIR
     bool PrintLIRWithAssembly                      = false           {C1 notproduct}Show LIR instruction with generated assembly
     bool CommentedAssembly                         = true            {C1 develop}Show extra info in PrintNMethods output
     bool LIRTracePeephole                          = false           {C1 develop}Trace peephole optimizer
     bool LIRTraceExecution                         = false           {C1 develop}add LIR code which logs the execution of blocks
     bool LIRFillDelaySlots                         = false           {C1 pd product}fill delays on on SPARC with LIR
     bool CSEArrayLength                            = false           {C1 pd develop}Create separate nodes for length in array accesses
     bool TwoOperandLIRForm                         = true            {C1 pd develop}true if LIR requires src1 and dst to match in binary LIR ops
     intx TraceLinearScanLevel                      = 0               {C1 develop}Debug levels for the linear scan allocator
     bool StressLinearScan                          = false           {C1 develop}scramble block order used by LinearScan (stress test)
     bool TimeLinearScan                            = false           {C1 product}detailed timing of LinearScan phases
     bool TimeEachLinearScan                        = false           {C1 develop}print detailed timing of each LinearScan run
     bool CountLinearScan                           = false           {C1 develop}collect statistic counters during LinearScan
     bool C1Breakpoint                              = false           {C1 develop}Sets a breakpoint at entry of each compiled method
     bool ImplicitDiv0Checks                        = true            {C1 develop}Use implicit division by zero checks
     bool PinAllInstructions                        = false           {C1 develop}All instructions are pinned
     bool UseFastNewInstance                        = true            {C1 develop}Use fast inlined instance allocation
     bool UseFastNewTypeArray                       = true            {C1 develop}Use fast inlined type array allocation
     bool UseFastNewObjectArray                     = true            {C1 develop}Use fast inlined object array allocation
     bool UseFastLocking                            = true            {C1 develop}Use fast inlined locking code
     bool UseSlowPath                               = false           {C1 develop}For debugging: test slow cases by always using them
     bool GenerateArrayStoreCheck                   = true            {C1 develop}Generates code for array store checks
     bool DeoptC1                                   = true            {C1 develop}Use deoptimization in C1
     bool PrintBailouts                             = false           {C1 develop}Print bailout and its reason
     bool TracePatching                             = false           {C1 develop}Trace patching of field access on uninitialized classes
     bool PatchALot                                 = false           {C1 develop}Marks all fields as having unloaded classes
     bool PrintNotLoaded                            = false           {C1 develop}Prints where classes are not loaded during code generation
     bool VerifyOopMaps                             = false           {C1 notproduct}Adds oopmap verification code to the generated code
     bool PrintLIR                                  = false           {C1 develop}print low-level IR
     bool BailoutAfterHIR                           = false           {C1 develop}bailout of compilation after building of HIR
     bool BailoutAfterLIR                           = false           {C1 develop}bailout of compilation after building of LIR
     bool BailoutOnExceptionHandlers                = false           {C1 develop}bailout of compilation for methods with exception handlers
     bool InstallMethods                            = true            {C1 develop}Install methods at the end of successful compilations
     intx CompilationRepeat                         = 0               {C1 product}Number of times to recompile method before returning result
     intx NMethodSizeLimit                          = 262144          {C1 develop}Maximum size of a compiled method.
     bool TraceFPUStack                             = false           {C1 develop}Trace emulation of the FPU stack (intel only)
     bool TraceFPURegisterUsage                     = false           {C1 develop}Trace usage of FPU registers at start of blocks (intel only)
     bool OptimizeUnsafes                           = true            {C1 develop}Optimize raw unsafe ops
     bool PrintUnsafeOptimization                   = false           {C1 develop}Print optimization of raw unsafe ops
     intx InstructionCountCutoff                    = 37000           {C1 develop}If GraphBuilder adds this many instructions, bails out
     intx SafepointPollOffset                       = 256             {C1 pd product}Offset added to polling address (Intel only)
     bool ComputeExactFPURegisterUsage              = true            {C1 develop}Compute additional live set for fpu registers to simplify fpu stack merge (Intel only)
     bool C1ProfileCalls                            = true            {C1 product}Profile calls when generating code for updating MDOs
     bool C1ProfileVirtualCalls                     = true            {C1 product}Profile virtual calls when generating code for updating MDOs
     bool C1ProfileInlinedCalls                     = true            {C1 product}Profile inlined calls when generating code for updating MDOs
     bool C1ProfileBranches                         = true            {C1 product}Profile branches when generating code for updating MDOs
     bool C1ProfileCheckcasts                       = true            {C1 product}Profile checkcasts when generating code for updating MDOs
     bool C1OptimizeVirtualCallProfiling            = true            {C1 product}Use CHA and exact type results at call sites when updating MDOs
     bool C1UpdateMethodData                        = false           {C1 product}Update MethodData*s in Tier1-generated code
     bool PrintCFGToFile                            = false           {C1 develop}print control flow graph to a separate file during compilation
     bool C1PatchInvokeDynamic                      = true            {C1 diagnostic}Patch invokedynamic appendix not known at compile time
     bool IEEEPrecision                             = true            {ARCH develop}Enables IEEE precision (for INTEL only)
     intx FenceInstruction                          = 0               {ARCH product}(Unsafe,Unstable) Experimental
     intx ReadPrefetchInstr                         = 0               {ARCH product}Prefetch instruction to prefetch ahead
     bool UseStoreImmI16                            = true            {ARCH product}Use store immediate 16-bits value instruction on x86
     intx UseAVX                                    = 99              {ARCH product}Highest supported AVX instructions set on x86/x64
     bool UseCLMUL                                  = false           {ARCH product}Control whether CLMUL instructions can be used on x86/x64
     bool UseIncDec                                 = true            {ARCH diagnostic}Use INC, DEC instructions on x86
     bool UseNewLongLShift                          = false           {ARCH product}Use optimized bitwise shift left
     bool UseAddressNop                             = false           {ARCH product}Use '0F 1F [addr]' NOP instructions on x86 cpus
     bool UseXmmLoadAndClearUpper                   = true            {ARCH product}Load low part of XMM register and clear upper part
     bool UseXmmRegToRegMoveAll                     = false           {ARCH product}Copy all XMM register bits when moving value between registers
     bool UseXmmI2D                                 = false           {ARCH product}Use SSE2 CVTDQ2PD instruction to convert Integer to Double
     bool UseXmmI2F                                 = false           {ARCH product}Use SSE2 CVTDQ2PS instruction to convert Integer to Float
     bool UseUnalignedLoadStores                    = false           {ARCH product}Use SSE2 MOVDQU instruction for Arraycopy
     bool UseFastStosb                              = false           {ARCH product}Use fast-string operation for zeroing: rep stosb
     bool Use486InstrsOnly                          = false           {ARCH product}Use 80486 Compliant instruction subset
     bool UseCountLeadingZerosInstruction           = false           {ARCH product}Use count leading zeros instruction
